var documenterSearchIndex = {"docs":
[{"location":"api/bases/#Bases","page":"Bases","title":"Bases","text":"Bases provide the reference frame for expressing quantum states. QSymbolic.jl supports explicit named bases with automatic orthonormality.","category":"section"},{"location":"api/bases/#Overview","page":"Bases","title":"Overview","text":"Type Description\nBasis A named orthonormal basis for a Hilbert space\nDefaultBasis Implicit basis from HilbertSpace destructuring\nCompositeBasis Tensor product of bases","category":"section"},{"location":"api/bases/#Types","page":"Bases","title":"Types","text":"","category":"section"},{"location":"api/bases/#Accessor-Functions","page":"Bases","title":"Accessor Functions","text":"","category":"section"},{"location":"api/bases/#Tensor-Product","page":"Bases","title":"Tensor Product","text":"Use âŠ— to combine bases:","category":"section"},{"location":"api/bases/#Examples","page":"Bases","title":"Examples","text":"using QSymbolic\n\n# Create space with destructuring (gets default basis)\nH, Hb = HilbertSpace(:spin, 2)\n\n# Create named bases\nZb = Basis(H, :z)\nXb = Basis(H, :x)\n\n# Get the space a basis is defined on\nspace(Zb)  # â†’ HilbertSpace{(:spin,), (2,)}\n\n# Get the basis name\nbasisname(Zb)  # â†’ :z\n\n# Composite basis\nH_A = HilbertSpace(:A, 2)\nH_B = HilbertSpace(:B, 2)\nZa = Basis(H_A, :z)\nZb = Basis(H_B, :z)\nZaZb = Za âŠ— Zb  # CompositeBasis\n\n# Access components\nbasis1(ZaZb)  # â†’ typeof(Za)\nbasis2(ZaZb)  # â†’ typeof(Zb)\n\n# Three-way composite\nH_C = HilbertSpace(:C, 2)\nZc = Basis(H_C, :z)\nZaZbZc = Za âŠ— Zb âŠ— Zc\nbases(ZaZbZc)  # â†’ (Za, Zb, Zc) types","category":"section"},{"location":"api/bases/#QSymbolic.AbstractBasis","page":"Bases","title":"QSymbolic.AbstractBasis","text":"AbstractBasis{space}\n\nAbstract supertype for bases defined on a Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"api/bases/#QSymbolic.Basis","page":"Bases","title":"QSymbolic.Basis","text":"Basis(space, name::Symbol)\n\nA named orthonormal basis for a Hilbert space. Kets in same basis are orthonormal; cross-basis inner products require a transform.\n\nExamples\n\njulia> H = HilbertSpace(:spin, 2);\n\njulia> Zb = Basis(H, :z)  # spin-z basis\nBasis{z}\n\njulia> Xb = Basis(H, :x)  # spin-x basis\nBasis{x}\n\nSee also: define_transform!, DefaultBasis, CompositeBasis\n\n\n\n\n\n","category":"type"},{"location":"api/bases/#QSymbolic.DefaultBasis","page":"Bases","title":"QSymbolic.DefaultBasis","text":"DefaultBasis{S}\n\nImplicit basis when no explicit basis is specified. Provides backward compatibility for code that creates kets directly from spaces without specifying a basis.\n\nExamples\n\njulia> _, Hb = HilbertSpace(:H, 2);\n\njulia> Ïˆ = Ket(Hb, :Ïˆ)  # uses DefaultBasis\n|ÏˆâŸ©\n\n\n\n\n\n","category":"type"},{"location":"api/bases/#QSymbolic.CompositeBasis","page":"Bases","title":"QSymbolic.CompositeBasis","text":"CompositeBasis{Bs<:Tuple}\n\nTensor product of bases. Created via basis1 âŠ— basis2 or basis1 âŠ— basis2 âŠ— basis3 âŠ— ....\n\nSupports arbitrary number of component bases using tuple type parameters.\n\nTransforms factorize automatically: if transforms exist for each component basis, tensor product transforms are automatically derived without explicit definition.\n\nExamples\n\njulia> H1, H2 = HilbertSpace(:A, 2), HilbertSpace(:B, 2);\n\njulia> Za, Zb = Basis(H1, :z), Basis(H2, :z);\n\njulia> Za âŠ— Zb\nBasis{z}âŠ—Basis{z}\n\njulia> H3 = HilbertSpace(:C, 2);\n\njulia> Zc = Basis(H3, :z);\n\njulia> Za âŠ— Zb âŠ— Zc  # Three bases\nBasis{z}âŠ—Basis{z}âŠ—Basis{z}\n\nSee also: Basis, define_transform!\n\n\n\n\n\n","category":"type"},{"location":"api/bases/#QSymbolic.space","page":"Bases","title":"QSymbolic.space","text":"space(basis)\nspace(ket_or_bra)\nspace(operator)\n\nGet the underlying Hilbert space of a basis, ket, bra, or operator.\n\n\n\n\n\n","category":"function"},{"location":"api/bases/#QSymbolic.basisname","page":"Bases","title":"QSymbolic.basisname","text":"basisname(basis)\n\nGet the symbolic name of a basis.\n\n\n\n\n\n","category":"function"},{"location":"api/bases/#QSymbolic.basis1","page":"Bases","title":"QSymbolic.basis1","text":"basis1(cb::CompositeBasis)\n\nGet the first component basis of a composite basis.\n\n\n\n\n\n","category":"function"},{"location":"api/bases/#QSymbolic.basis2","page":"Bases","title":"QSymbolic.basis2","text":"basis2(cb::CompositeBasis)\n\nGet the second component basis of a composite basis.\n\n\n\n\n\n","category":"function"},{"location":"api/bases/#QSymbolic.:âŠ—-Tuple{AbstractBasis, AbstractBasis}","page":"Bases","title":"QSymbolic.:âŠ—","text":"âŠ—(basis1::AbstractBasis, basis2::AbstractBasis)\nâŠ—(cb::CompositeBasis, basis::AbstractBasis)\nâŠ—(basis::AbstractBasis, cb::CompositeBasis)\n\nTensor product of bases. Supports chaining for multiple bases.\n\n\n\n\n\n","category":"method"},{"location":"guide/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide introduces the basic concepts of QSymbolic.jl for symbolic quantum mechanics.","category":"section"},{"location":"guide/getting_started/#Hilbert-Spaces-and-Bases","page":"Getting Started","title":"Hilbert Spaces and Bases","text":"A Hilbert space is the fundamental mathematical arena for quantum mechanics. In QSymbolic.jl, you create spaces with the HilbertSpace constructor:\n\nusing QSymbolic\n\n# Finite-dimensional space (e.g., qubit with 2 dimensions)\nH = HilbertSpace(:qubit, 2)\n\n# Infinite-dimensional space (e.g., harmonic oscillator)\nF = HilbertSpace(:oscillator)\n\n# Convenience alias for Fock spaces\nF = FockSpace(:oscillator)  # equivalent to HilbertSpace(:oscillator)","category":"section"},{"location":"guide/getting_started/#Creating-Bases","page":"Getting Started","title":"Creating Bases","text":"Every ket lives in a basis. Create named bases with Basis(space, name):\n\nH = HilbertSpace(:spin, 2)\n\n# Create named bases\nZb = Basis(H, :z)   # spin-z eigenbasis\nXb = Basis(H, :x)   # spin-x eigenbasis","category":"section"},{"location":"guide/getting_started/#Convenient-Destructuring","page":"Getting Started","title":"Convenient Destructuring","text":"HilbertSpace supports destructuring to get both a space and a default basis in one line:\n\n# Get space AND default basis\nH, Hb = HilbertSpace(:H, 2)\n\n# Equivalent to:\n# H = HilbertSpace(:H, 2)\n# Hb = Basis(H, :default)\n\n# Same works for FockSpace\nF, Fb = FockSpace(:mode)\n\nThis pattern is convenient and used throughout the documentation.","category":"section"},{"location":"guide/getting_started/#States:-Kets-and-Bras","page":"Getting Started","title":"States: Kets and Bras","text":"Quantum states are represented in Dirac notation. A ket |ÏˆâŸ© represents a quantum state, and its dual bra âŸ¨Ïˆ| is the conjugate transpose.","category":"section"},{"location":"guide/getting_started/#Creating-Kets","page":"Getting Started","title":"Creating Kets","text":"H, Hb = HilbertSpace(:H, 2)\n\n# Create kets with symbolic labels\nÏˆ = Ket(Hb, :Ïˆ)\nÏ• = Ket(Hb, :Ï•)\n\n# Display uses Dirac notation\nÏˆ   # â†’ |ÏˆâŸ©\n\n# Get the bra (conjugate transpose) via adjoint\nÏˆ'  # â†’ âŸ¨Ïˆ|","category":"section"},{"location":"guide/getting_started/#Numeric-Indices-(Fock-States)","page":"Getting Started","title":"Numeric Indices (Fock States)","text":"For number states, use integer indices:\n\nF, Fb = FockSpace(:mode)\n\n# Number states |nâŸ©\nn0 = Ket(Fb, 0)   # Ground state |0âŸ©\nn1 = Ket(Fb, 1)   # First excited |1âŸ©\nn2 = Ket(Fb, 2)   # Second excited |2âŸ©\n\n# Orthonormality\nn0' * n0  # â†’ 1\nn0' * n1  # â†’ 0","category":"section"},{"location":"guide/getting_started/#Symbolic-Indices","page":"Getting Started","title":"Symbolic Indices","text":"Kets can have symbolic indices for general representations:\n\nF, Fb = FockSpace(:mode)\n\n# Create symbolic index\nn = Sym(:n, :nonnegative, :integer)\n\n# Ket with symbolic index\nket_n = Ket(Fb, n)   # |nâŸ©\n\n# Inner products give KroneckerDelta\nm = Sym(:m, :nonnegative, :integer)\nKet(Fb, m)' * ket_n  # â†’ Î´(m,n)\n\nnote: Orthonormality\nStates in the same basis with different labels are automatically orthogonal. This reflects the standard assumption that basis states form an orthonormal set.","category":"section"},{"location":"guide/getting_started/#Inner-Products","page":"Getting Started","title":"Inner Products","text":"Inner products follow quantum mechanics conventions with âŸ¨bra|ketâŸ© notation:\n\nH, Hb = HilbertSpace(:H, 2)\nÏˆ = Ket(Hb, :Ïˆ)\nÏ• = Ket(Hb, :Ï•)\n\n# Orthonormal basis states\nÏˆ' * Ïˆ  # â†’ 1 (normalized)\nÏˆ' * Ï•  # â†’ 0 (orthogonal - different labels)\n\n# Inner product of superpositions expands linearly\n# âŸ¨Ïˆ + Ï•|Ïˆ + Ï•âŸ© = âŸ¨Ïˆ|ÏˆâŸ© + âŸ¨Ïˆ|Ï•âŸ© + âŸ¨Ï•|ÏˆâŸ© + âŸ¨Ï•|Ï•âŸ© = 1 + 0 + 0 + 1 = 2\n(Ïˆ + Ï•)' * (Ïˆ + Ï•)  # â†’ 2","category":"section"},{"location":"guide/getting_started/#Linear-Combinations-(Superpositions)","page":"Getting Started","title":"Linear Combinations (Superpositions)","text":"Quantum superpositions are built using standard arithmetic:\n\nH, Hb = HilbertSpace(:H, 2)\nÏˆ = Ket(Hb, :Ïˆ)\nÏ• = Ket(Hb, :Ï•)\n\n# Scalar multiplication\n2 * Ïˆ           # â†’ 2|ÏˆâŸ©\n\n# Addition creates superpositions\nÏˆ + Ï•           # â†’ |ÏˆâŸ© + |Ï•âŸ©\n\n# Subtraction\nÏˆ - Ï•           # â†’ |ÏˆâŸ© - |Ï•âŸ©\n\n# Division by scalars (for normalization)\n(Ïˆ + Ï•) / âˆš2    # â†’ (|ÏˆâŸ© + |Ï•âŸ©)/âˆš2\n\n# Rational division also works\nÏˆ // 2          # â†’ (1//2)|ÏˆâŸ©","category":"section"},{"location":"guide/getting_started/#Type-Promotion","page":"Getting Started","title":"Type Promotion","text":"Operations automatically create appropriate types:\n\nOperation Input Result Type\nÎ± * Ïˆ Scalar Ã— Ket WeightedKet\nÏˆ + Ï• Ket + Ket SumKet\nÏˆ âŠ— Ï• Ket âŠ— Ket ProductKet","category":"section"},{"location":"guide/getting_started/#Symbolic-Scalars","page":"Getting Started","title":"Symbolic Scalars","text":"QSymbolic.jl uses Symbolics.jl for symbolic computation. Create symbolic variables with Sym:\n\n# Basic symbolic variable\nn = Sym(:n)\n\n# With type assumptions\nÎ¸ = Sym(:Î¸, :real)\nk = Sym(:k, :positive, :integer)\n\n# Using Symbolics.jl macros (re-exported)\n@variables x y z\n@syms Î± Î²","category":"section"},{"location":"guide/getting_started/#Assumptions","page":"Getting Started","title":"Assumptions","text":"Assumptions affect simplification and conjugation:\n\n# Complex (default) - conjugate applies\nz = Sym(:z)\nz'  # â†’ conj(z)\n\n# Real - self-conjugate\nr = Sym(:r, :real)\nr'  # â†’ r\n\n# Available: :real, :positive, :negative, :nonnegative, :integer","category":"section"},{"location":"guide/getting_started/#Symbolic-State-Coefficients","page":"Getting Started","title":"Symbolic State Coefficients","text":"H, Hb = HilbertSpace(:H, 2)\nÏˆ = Ket(Hb, :Ïˆ)\nÏ• = Ket(Hb, :Ï•)\n\n# Symbolic amplitudes\nÎ± = Sym(:Î±)\nÎ² = Sym(:Î²)\n\n# Superposition with symbolic coefficients\nstate = Î± * Ïˆ + Î² * Ï•  # â†’ Î±|ÏˆâŸ© + Î²|Ï•âŸ©","category":"section"},{"location":"guide/getting_started/#Outer-Products-and-Operators","page":"Getting Started","title":"Outer Products and Operators","text":"Create operators via outer products |ÏˆâŸ©âŸ¨Ï•|:\n\nH, Hb = HilbertSpace(:spin, 2)\nZb = Basis(H, :z)\n\nup = Ket(Zb, :â†‘)\ndown = Ket(Zb, :â†“)\n\n# Projector onto |â†‘âŸ©\nP_up = up * up'      # |â†‘âŸ©âŸ¨â†‘|\n\n# Apply to states\nP_up * up    # â†’ |â†‘âŸ©\nP_up * down  # â†’ 0\n\n# Ladder operator\nÏƒ_plus = up * down'  # |â†‘âŸ©âŸ¨â†“|\nÏƒ_plus * down  # â†’ |â†‘âŸ©\n\n# Pauli Z\nÏƒz = up * up' - down * down'\nÏƒz * up    # â†’ |â†‘âŸ©\nÏƒz * down  # â†’ -|â†“âŸ©","category":"section"},{"location":"guide/getting_started/#Quick-Example:-Spin-1/2-System","page":"Getting Started","title":"Quick Example: Spin-1/2 System","text":"using QSymbolic\n\n# Create 2D Hilbert space with z-basis\nH = HilbertSpace(:spin, 2)\nZb = Basis(H, :z)\n\n# Basis states\nup = Ket(Zb, :â†‘)\ndown = Ket(Zb, :â†“)\n\n# Superposition (equal superposition)\nÏˆ = (up + down) / âˆš2\n\n# Check normalization\nÏˆ' * Ïˆ  # â†’ 1\n\n# Pauli operators\nÏƒz = up * up' - down * down'\nÏƒx = up * down' + down * up'\n\n# Apply operators\nÏƒz * up     # â†’ |â†‘âŸ©\nÏƒz * down   # â†’ -|â†“âŸ©\nÏƒx * up     # â†’ |â†“âŸ©\nÏƒx * down   # â†’ |â†‘âŸ©\n\n# Measurement probability\n# P(â†‘) = |âŸ¨â†‘|ÏˆâŸ©|Â² \nup' * Ïˆ  # â†’ 1/âˆš2, so P(â†‘) = 1/2","category":"section"},{"location":"guide/getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Basis Transforms - Changing between representations (z â†” x basis)\nComposite Systems - Multi-particle states and tensor products\nOperators - Function operators and operator algebra\nSymbolic Scalars - Advanced symbolic computation\nCustom Contraction Rules - Non-orthonormal bases","category":"section"},{"location":"api/spaces/#Spaces","page":"Spaces","title":"Spaces","text":"Hilbert spaces form the mathematical foundation of quantum mechanics. QSymbolic.jl provides types to represent both simple and composite spaces.","category":"section"},{"location":"api/spaces/#Overview","page":"Spaces","title":"Overview","text":"Type Description\nHilbertSpace A single named Hilbert space (finite or infinite-dimensional)\nCompositeSpace Tensor product of two or more spaces\nFockSpace Convenience constructor for infinite-dimensional spaces","category":"section"},{"location":"api/spaces/#Types","page":"Spaces","title":"Types","text":"","category":"section"},{"location":"api/spaces/#Tensor-Product","page":"Spaces","title":"Tensor Product","text":"Use âŠ— (typed as \\otimes<tab>) to create composite spaces:","category":"section"},{"location":"api/spaces/#Examples","page":"Spaces","title":"Examples","text":"using QSymbolic\n\n# Single qubit\nH = HilbertSpace(:qubit, 2)\nHb = Basis(H, :default)\n\n# Harmonic oscillator (infinite-dimensional)  \nF = FockSpace(:oscillator)\n\n# Two-qubit system\nH_AB = HilbertSpace(:A, 2) âŠ— HilbertSpace(:B, 2)","category":"section"},{"location":"api/spaces/#QSymbolic.AbstractSpace","page":"Spaces","title":"QSymbolic.AbstractSpace","text":"AbstractSpace{name, dim}\n\nAbstract supertype for all quantum state spaces.\n\nType parameters:\n\nname: Tuple of symbols identifying the space\ndim: Tuple of dimensions (or nothing for infinite-dim)\n\n\n\n\n\n","category":"type"},{"location":"api/spaces/#QSymbolic.HilbertSpace","page":"Spaces","title":"QSymbolic.HilbertSpace","text":"HilbertSpace(name::Symbol, dim=nothing)\n\nA named Hilbert space with optional finite dimension.\n\nExamples\n\njulia> H = HilbertSpace(:H, 2)  # qubit\nâ„‹(H, dim=2)\n\njulia> F = HilbertSpace(:F)     # infinite-dim\nâ„‹(F)\n\n\n\n\n\n","category":"type"},{"location":"api/spaces/#QSymbolic.CompositeSpace","page":"Spaces","title":"QSymbolic.CompositeSpace","text":"CompositeSpace(space1, space2)\n\nTensor product of two spaces. Usually created via space1 âŠ— space2.\n\nExamples\n\njulia> H1 = HilbertSpace(:A, 2);\n\njulia> H2 = HilbertSpace(:B, 3);\n\njulia> H1 âŠ— H2\nâ„‹(A) âŠ— â„‹(B)\n\n\n\n\n\n","category":"type"},{"location":"api/spaces/#QSymbolic.FockSpace","page":"Spaces","title":"QSymbolic.FockSpace","text":"FockSpace(name::Symbol)\n\nCreate an infinite-dimensional Fock space (number state basis). Equivalent to HilbertSpace(name, nothing).\n\nExamples\n\njulia> F = FockSpace(:F)\nâ„‹(F)\n\n\n\n\n\n","category":"function"},{"location":"api/spaces/#QSymbolic.:âŠ—-Tuple{AbstractSpace, AbstractSpace}","page":"Spaces","title":"QSymbolic.:âŠ—","text":"âŠ—(space1::AbstractSpace, space2::AbstractSpace)\n\nTensor product of two Hilbert spaces.\n\n\n\n\n\n","category":"method"},{"location":"guide/symbolic/#Symbolic-Scalars","page":"Symbolic Scalars","title":"Symbolic Scalars","text":"QSymbolic.jl uses Symbolics.jl as its backend for symbolic computation. A thin compatibility layer provides a familiar API while leveraging Symbolics.jl's powerful computer algebra system.","category":"section"},{"location":"guide/symbolic/#Why-Symbolic-Scalars?","page":"Symbolic Scalars","title":"Why Symbolic Scalars?","text":"In quantum mechanical calculations, you often want to keep expressions symbolic:\n\nDerive general formulas with parameters like n, Î¸, Ï‰\nSubstitute specific values later\nAvoid floating-point errors in intermediate steps\nGenerate readable analytical expressions","category":"section"},{"location":"guide/symbolic/#Creating-Symbolic-Variables","page":"Symbolic Scalars","title":"Creating Symbolic Variables","text":"","category":"section"},{"location":"guide/symbolic/#Using-Sym-(QSymbolic-API)","page":"Symbolic Scalars","title":"Using Sym (QSymbolic API)","text":"The Sym constructor creates symbolic variables with optional type assumptions:\n\nusing QSymbolic\n\nn = Sym(:n)           # Generic symbolic variable\nÎ¸ = Sym(:Î¸)           # Greek letters work too\nÏ‰ = Sym(:Ï‰, :real)    # Real-valued\n\n# Display shows the symbol name\nn  # â†’ n","category":"section"},{"location":"guide/symbolic/#Using-Symbolics.jl-Macros-(Re-exported)","page":"Symbolic Scalars","title":"Using Symbolics.jl Macros (Re-exported)","text":"QSymbolic re-exports @variables and @syms from Symbolics.jl:\n\nusing QSymbolic\n\n# Create multiple variables at once\n@variables x y z\n@syms a b c\n\n# With type annotations\n@variables t::Real\n@variables n::Integer","category":"section"},{"location":"guide/symbolic/#Type-Assumptions","page":"Symbolic Scalars","title":"Type Assumptions","text":"Symbolic variables can carry assumptions that affect simplification and conjugation:\n\n# Positional syntax\nn = Sym(:n, :integer)           # n is an integer\nÎ¸ = Sym(:Î¸, :real)              # Î¸ is real\np = Sym(:p, :positive)          # p > 0 (implies real)\nE = Sym(:E, :nonnegative)       # E â‰¥ 0\n\n# Keyword syntax\nk = Sym(:k, integer=true)\nr = Sym(:r, real=true, positive=true)\n\n# Multiple assumptions\nm = Sym(:m, :real, :positive, :integer)","category":"section"},{"location":"guide/symbolic/#Querying-Assumptions","page":"Symbolic Scalars","title":"Querying Assumptions","text":"n = Sym(:n, :integer)\np = Sym(:p, :positive)\n\nis_integer(n)       # â†’ true\nis_positive(p)      # â†’ true\nis_real(p)          # â†’ true (positive implies real)\nis_nonnegative(p)   # â†’ true (positive implies nonnegative)\n\nassumptions(n)      # â†’ Set([:integer])","category":"section"},{"location":"guide/symbolic/#Effect-on-Conjugation","page":"Symbolic Scalars","title":"Effect on Conjugation","text":"Assumptions affect how the adjoint (complex conjugate) behaves:\n\nz = Sym(:z)                    # Complex by default\nz'                             # â†’ conj(z)\n\nr = Sym(:r, :real)\nr'                             # â†’ r (real variables self-conjugate)","category":"section"},{"location":"guide/symbolic/#Building-Expressions","page":"Symbolic Scalars","title":"Building Expressions","text":"Arithmetic operations build expression trees automatically:\n\nn = Sym(:n)\n\n# Basic arithmetic\nn + 1        # â†’ n + 1\nn - 2        # â†’ n - 2\nn * 3        # â†’ 3n\nn / 4        # â†’ n/4\nn^2          # â†’ nÂ²\n\n# Square root\nâˆšn           # â†’ âˆšn\nsqrt(n)      # â†’ âˆšn\n\n# Combinations\nâˆšn + 1       # â†’ 1 + âˆšn\nn^2 + 2n     # â†’ nÂ² + 2n","category":"section"},{"location":"guide/symbolic/#Supported-Operations","page":"Symbolic Scalars","title":"Supported Operations","text":"Operation Syntax Example\nAddition + n + 1\nSubtraction - n - 1\nNegation - -n\nMultiplication * n * 2\nDivision /, // n / 2\nPower ^ n^2\nSquare root âˆš, sqrt âˆšn\nConjugate conj conj(z)\nAbsolute value abs, abs2 abs(z)\nTrigonometric sin, cos, tan sin(Î¸)\nExponential exp, log exp(x)","category":"section"},{"location":"guide/symbolic/#Substitution","page":"Symbolic Scalars","title":"Substitution","text":"Replace symbolic variables with values using substitute:\n\nn = Sym(:n)\nexpr = âˆšn + 1\n\n# Substitute n â†’ 4\nresult = substitute(expr, :n => 4)\nresult  # â†’ 1 + âˆš4 = 3\n\n# Multiple substitutions\n@syms a b\nexpr = a^2 + b^2\nsubstitute(expr, :a => 3, :b => 4)  # â†’ 25\n\n# Partial substitution\nexpr = a * b + a\nsubstitute(expr, :a => 2)  # â†’ 2b + 2 (b remains symbolic)","category":"section"},{"location":"guide/symbolic/#Evaluation","page":"Symbolic Scalars","title":"Evaluation","text":"Convert expressions to numeric values with evaluate:\n\nn = Sym(:n)\nexpr = âˆšn + 1\n\n# Substitute then evaluate\nresult = substitute(expr, :n => 4)\nevaluate(result)  # â†’ 3.0\n\n# Chained\nsubstitute(expr, :n => 9) |> evaluate  # â†’ 4.0\n\nwarning: All Symbols Must Be Substituted\nevaluate throws an error if symbolic variables remain:evaluate(Sym(:n))  # Error: Cannot evaluate expression with free symbols","category":"section"},{"location":"guide/symbolic/#Simplification","page":"Symbolic Scalars","title":"Simplification","text":"Apply algebraic simplifications with simplify:\n\nn = Sym(:n)\n\n# Identity simplifications\nsimplify(n * 1)   # â†’ n\nsimplify(n * 0)   # â†’ 0\nsimplify(n + 0)   # â†’ n\nsimplify(n^1)     # â†’ n\nsimplify(n^0)     # â†’ 1\n\n# Numeric folding\nsimplify(2 + 3)   # â†’ 5\n\n# Expression simplification\nsimplify(n + n)   # â†’ 2n","category":"section"},{"location":"guide/symbolic/#Introspection","page":"Symbolic Scalars","title":"Introspection","text":"","category":"section"},{"location":"guide/symbolic/#List-Symbols-in-Expression","page":"Symbolic Scalars","title":"List Symbols in Expression","text":"@syms n m\nexpr = n^2 + 2*n*m + m^2\n\nsymbols(expr)  # â†’ Set([:n, :m])","category":"section"},{"location":"guide/symbolic/#Check-if-Numeric","page":"Symbolic Scalars","title":"Check if Numeric","text":"n = Sym(:n)\nexpr = âˆšn + 1\n\nis_numeric(n)                        # â†’ false\nis_numeric(5)                        # â†’ true\nis_numeric(expr)                     # â†’ false (contains n)\nis_numeric(substitute(expr, :n => 4))  # â†’ true","category":"section"},{"location":"guide/symbolic/#KroneckerDelta","page":"Symbolic Scalars","title":"KroneckerDelta","text":"The KroneckerDelta type represents the Kronecker delta function Î´áµ¢â±¼:\n\ndelta_ij = begincases 1  textif  i = j  0  textif  i neq j endcases\n\nusing QSymbolic\n\nn = Sym(:n)\nm = Sym(:m)\n\n# Create Kronecker delta\nÎ´ = KroneckerDelta(n, m)\nÎ´  # â†’ Î´(n,m)\n\n# Same variable simplifies to 1\nKroneckerDelta(n, n) |> simplify  # â†’ 1\n\n# Concrete values evaluate immediately\nKroneckerDelta(1, 1)  # â†’ 1\nKroneckerDelta(1, 2)  # â†’ 0\n\n# Literal Symbols (not Sym) compare directly\nKroneckerDelta(:a, :a) |> simplify  # â†’ 1\nKroneckerDelta(:a, :b) |> simplify  # â†’ 0\n\n# Different symbolic variables remain symbolic\na = Sym(:a)\nb = Sym(:b)\nKroneckerDelta(a, b) |> simplify  # â†’ Î´(a,b) (could be equal after substitution)","category":"section"},{"location":"guide/symbolic/#KroneckerDelta-in-Inner-Products","page":"Symbolic Scalars","title":"KroneckerDelta in Inner Products","text":"Kronecker deltas arise naturally from inner products with symbolic indices:\n\nH, Hb = HilbertSpace(:H, 2)\n\nn = Sym(:n)\nm = Sym(:m)\n\nket_n = Ket(Hb, n)\nket_m = Ket(Hb, m)\n\n# Inner product gives Kronecker delta\nket_m' * ket_n  # â†’ Î´(m,n)\nket_n' * ket_n  # â†’ 1 (same index)","category":"section"},{"location":"guide/symbolic/#Multi-Index-Kronecker-Deltas","page":"Symbolic Scalars","title":"Multi-Index Kronecker Deltas","text":"For composite indices, KroneckerDelta products merge:\n\nn, m = Sym(:n), Sym(:m)\nÏƒ, Î¾ = Sym(:Ïƒ), Sym(:Î¾)\n\n# Product of deltas\nÎ´1 = KroneckerDelta(n, m)\nÎ´2 = KroneckerDelta(Ïƒ, Î¾)\n\nÎ´1 * Î´2  # â†’ Î´(n,m)Â·Î´(Ïƒ,Î¾)","category":"section"},{"location":"guide/symbolic/#Use-with-Quantum-States","page":"Symbolic Scalars","title":"Use with Quantum States","text":"","category":"section"},{"location":"guide/symbolic/#Symbolic-Indices","page":"Symbolic Scalars","title":"Symbolic Indices","text":"Kets accept symbolic indices for general representations:\n\nusing QSymbolic\n\nS, B = FockSpace(:fock)\n\n# Create symbolic index\nn = Sym(:n)\n\n# Ket with symbolic index |nâŸ©\nket_n = Ket(B, n)\nket_n  # â†’ |nâŸ©\n\n# Adjoint preserves symbolic index\nket_n'  # â†’ âŸ¨n|\n\n# Inner products\nket_n' * ket_n  # â†’ 1\nm = Sym(:m)\nKet(B, m)' * ket_n  # â†’ Î´(m,n)","category":"section"},{"location":"guide/symbolic/#Symbolic-Weights","page":"Symbolic Scalars","title":"Symbolic Weights","text":"Weighted kets and superpositions can have symbolic coefficients:\n\nH, Hb = HilbertSpace(:H, 2)\nÏˆ = Ket(Hb, :Ïˆ)\nÏ• = Ket(Hb, :Ï•)\n\n# Symbolic amplitudes\nÎ± = Sym(:Î±)\nÎ² = Sym(:Î²)\n\n# Weighted ket\nÎ± * Ïˆ  # â†’ Î±Â·|ÏˆâŸ©\n\n# Superposition with symbolic amplitudes\nstate = Î± * Ïˆ + Î² * Ï•  # â†’ Î±Â·|ÏˆâŸ© + Î²Â·|Ï•âŸ©","category":"section"},{"location":"guide/symbolic/#Example:-Parametric-Expressions","page":"Symbolic Scalars","title":"Example: Parametric Expressions","text":"using QSymbolic\n\n# Define parameters\nn = Sym(:n, :nonnegative, :integer)\nÏ‰ = Sym(:Ï‰, :positive)\n\n# Harmonic oscillator energy\nE_n = Ï‰ * (n + 1//2)\nE_n  # â†’ Ï‰*(n + 1/2)\n\n# Substitute specific values\nE_0 = substitute(E_n, :n => 0)\nE_0  # â†’ Ï‰/2\n\nE_0_numeric = substitute(E_0, :Ï‰ => 2Ï€)\nevaluate(E_0_numeric)  # â†’ Ï€ â‰ˆ 3.14159...","category":"section"},{"location":"guide/symbolic/#Type-System","page":"Symbolic Scalars","title":"Type System","text":"QSymbolic uses Symbolics.jl types internally:\n\n# AbstractSymbolic is an alias for Symbolics types\nconst AbstractSymbolic = Union{Symbolics.Num, Complex{Symbolics.Num}}\n\n# Check if a value is symbolic\nx isa AbstractSymbolic\n\n# Sym creates Symbolics.Num variables\nn = Sym(:n)\ntypeof(n)  # â†’ Num","category":"section"},{"location":"guide/symbolic/#Compatibility-Types","page":"Symbolic Scalars","title":"Compatibility Types","text":"For backward compatibility, these constructors are provided:\n\nConstructor Behavior\nSym(:name) Creates Symbolics.Num variable\nSymNum(x) Returns x unchanged (passthrough)\nSymExpr(op, args...) Builds expression via arithmetic","category":"section"},{"location":"guide/symbolic/#API-Summary","page":"Symbolic Scalars","title":"API Summary","text":"Function Description\nSym(:name) Create symbolic variable\nSym(:name, :assumption...) Create with assumptions\n@variables x y z Create multiple variables (Symbolics.jl)\n@syms a b c Create multiple variables (Symbolics.jl)\nKroneckerDelta(i, j) Kronecker delta Î´áµ¢â±¼\nsubstitute(expr, pairs...) Replace symbols with values\nevaluate(expr) Compute numeric result\nsimplify(expr) Apply algebraic simplifications\nsymbols(expr) Get set of symbol names\nis_numeric(expr) Check if fully numeric\nis_real(sym) Check real assumption\nis_positive(sym) Check positive assumption\nis_integer(sym) Check integer assumption\nassumptions(sym) Get set of assumptions","category":"section"},{"location":"guide/symbolic/#See-Also","page":"Symbolic Scalars","title":"See Also","text":"Custom Contraction Rules - Define non-orthonormal inner products\nGetting Started - Basic quantum state operations","category":"section"},{"location":"guide/contraction_rules/#Custom-Contraction-Rules","page":"Custom Contraction Rules","title":"Custom Contraction Rules","text":"QSymbolic.jl allows you to define custom inner product behavior for specific bases. This is essential for modeling non-orthonormal bases, dressed states, or bases with special structure like Jaynes-Cummings states.","category":"section"},{"location":"guide/contraction_rules/#Why-Custom-Contraction-Rules?","page":"Custom Contraction Rules","title":"Why Custom Contraction Rules?","text":"By default, QSymbolic.jl assumes orthonormal bases:\n\nâŸ¨i|jâŸ© = 1 if indices are equal\nâŸ¨i|jâŸ© = 0 if indices differ\nâŸ¨i|jâŸ© = Î´áµ¢â±¼ (KroneckerDelta) if either index is symbolic\n\nBut many physical situations require different behavior:\n\nCoherent states: âŸ¨Î±|Î²âŸ© = exp(-|Î±-Î²|Â²/2) (non-orthogonal)\nDressed states: Custom overlap depending on quantum numbers\nMulti-index bases: Component-wise checking with special rules","category":"section"},{"location":"guide/contraction_rules/#Defining-a-Custom-Rule","page":"Custom Contraction Rules","title":"Defining a Custom Rule","text":"Use define_contraction_rule! to specify how inner products behave for a basis:\n\nusing QSymbolic\n\nH, Hb = HilbertSpace(:H, 2)\nmy_basis = Basis(H, :custom)\n\n# Define the contraction rule\ndefine_contraction_rule!(typeof(my_basis)) do bra_idx, ket_idx\n    # Your custom logic here\n    # Return: number, symbolic expression, or KroneckerDelta\nend\n\nThe rule function receives:\n\nbra_idx: The index from the bra âŸ¨bra_idx|\nket_idx: The index from the ket |ket_idxâŸ©\n\nAnd should return:\n\nA number (0, 1, 0.5, etc.)\nA symbolic expression\nA KroneckerDelta(i, j) for symbolic orthonormality","category":"section"},{"location":"guide/contraction_rules/#Example:-Orthonormal-Basis-(Default-Behavior)","page":"Custom Contraction Rules","title":"Example: Orthonormal Basis (Default Behavior)","text":"The default rule implements standard orthonormality:\n\nH, Hb = HilbertSpace(:H, 2)\nZb = Basis(H, :z)\n\n# This is what the default does (no need to define):\ndefine_contraction_rule!(typeof(Zb)) do i, j\n    if i isa AbstractSymbolic || j isa AbstractSymbolic\n        # Symbolic: return 1 if same symbol, else KroneckerDelta\n        return isequal(i, j) ? 1 : KroneckerDelta(i, j)\n    else\n        # Concrete: direct comparison\n        return isequal(i, j) ? 1 : 0\n    end\nend\n\nup = Ket(Zb, :â†‘)\ndown = Ket(Zb, :â†“)\n\nup' * up    # â†’ 1\nup' * down  # â†’ 0","category":"section"},{"location":"guide/contraction_rules/#Example:-Non-Orthogonal-Coherent-States","page":"Custom Contraction Rules","title":"Example: Non-Orthogonal Coherent States","text":"Coherent states have non-zero overlap:\n\nH, Hb = HilbertSpace(:oscillator)\nCb = Basis(H, :coherent)\n\ndefine_contraction_rule!(typeof(Cb)) do Î±, Î²\n    # âŸ¨Î±|Î²âŸ© = exp(-|Î±-Î²|Â²/2) Ã— exp(iÃ—Im(Î±*conj(Î²)))\n    # Simplified for real coherent amplitudes:\n    if Î± isa AbstractSymbolic || Î² isa AbstractSymbolic\n        # Keep symbolic\n        return exp(-abs(Î± - Î²)^2 / 2)\n    else\n        # Evaluate numerically\n        return exp(-abs(Î± - Î²)^2 / 2)\n    end\nend\n\n# Coherent states\nÎ± = Ket(Cb, 0.5)\nÎ² = Ket(Cb, 1.0)\n\nÎ±' * Î±  # â†’ 1 (self-overlap)\nÎ±' * Î²  # â†’ exp(-0.125) â‰ˆ 0.882 (non-zero overlap!)","category":"section"},{"location":"guide/contraction_rules/#Working-with-Symbolic-Indices","page":"Custom Contraction Rules","title":"Working with Symbolic Indices","text":"When indices are symbolic (using Sym), use these patterns:\n\n# Check if a value is symbolic\nx isa AbstractSymbolic  # true for Sym(:x), false for :x or 1\n\n# Compare values safely (works for symbols and numbers)\nisequal(a, b)  # Use this instead of ==\n\n# Return KroneckerDelta for symbolic orthonormality\nKroneckerDelta(i, j)  # Î´áµ¢â±¼ - simplifies to 0 or 1 when possible\n\n# Simplify expressions\nKroneckerDelta(i, j) |> simplify\n\nwarning: Use `isequal` not `==`\nAlways use isequal(a, b) for comparisons in contraction rules. Using == on symbolic expressions can throw errors or return symbolic booleans that break control flow.","category":"section"},{"location":"guide/contraction_rules/#API-Reference","page":"Custom Contraction Rules","title":"API Reference","text":"","category":"section"},{"location":"guide/contraction_rules/#define_contraction_rule!(basis_type,-rule)","page":"Custom Contraction Rules","title":"define_contraction_rule!(basis_type, rule)","text":"Define a custom contraction rule for a basis type.\n\ndefine_contraction_rule!(typeof(my_basis)) do bra_idx, ket_idx\n    # Return the inner product result\nend","category":"section"},{"location":"guide/contraction_rules/#has_contraction_rule(basis_type)","page":"Custom Contraction Rules","title":"has_contraction_rule(basis_type)","text":"Check if a custom rule exists:\n\nhas_contraction_rule(typeof(my_basis))  # â†’ true/false","category":"section"},{"location":"guide/contraction_rules/#clear_contraction_rules!()","page":"Custom Contraction Rules","title":"clear_contraction_rules!()","text":"Remove all custom rules, reverting to default orthonormal behavior:\n\nclear_contraction_rules!()","category":"section"},{"location":"guide/contraction_rules/#Best-Practices","page":"Custom Contraction Rules","title":"Best Practices","text":"Always handle both symbolic and concrete cases - Check isa AbstractSymbolic before comparisons\nUse isequal for comparisons - Avoids issues with symbolic equality\nSimplify results - Use |> simplify to reduce KroneckerDelta expressions\nReturn consistent types - Return numbers for concrete cases, symbolic expressions for symbolic cases\nDocument your rule - Complex contraction rules benefit from comments explaining the physics","category":"section"},{"location":"guide/contraction_rules/#See-Also","page":"Custom Contraction Rules","title":"See Also","text":"Getting Started - Basic ket/bra operations\nComposite Systems - Tensor products and multi-index states\nSymbolic Scalars - Working with symbolic expressions","category":"section"},{"location":"api/states/#States","page":"States","title":"States","text":"Quantum states are represented as kets |ÏˆâŸ© and their duals as bras âŸ¨Ïˆ|. QSymbolic.jl provides types for basis states, superpositions, and product states.","category":"section"},{"location":"api/states/#Overview","page":"States","title":"Overview","text":"Type Description\nKet / Bra Single basis state\nWeightedKet / WeightedBra Scalar Ã— basis state\nSumKet / SumBra Linear combination of basis states\nProductKet / ProductBra Tensor product of states (order-independent)","category":"section"},{"location":"api/states/#Index-Types","page":"States","title":"Index Types","text":"Kets support flexible indices:\n\n# Single index\nKet(basis, :Ïˆ)           # Symbol\nKet(basis, 0)            # Integer (Fock states)\nKet(basis, Sym(:n))      # Symbolic\n\n# Multi-index (for composite bases)\nKet(basis, (n, m))       # Tuple of indices\nKet(basis, (n, m, k))    # Arbitrary length","category":"section"},{"location":"api/states/#Single-System-States","page":"States","title":"Single-System States","text":"","category":"section"},{"location":"api/states/#Abstract-Types","page":"States","title":"Abstract Types","text":"","category":"section"},{"location":"api/states/#Basis-States","page":"States","title":"Basis States","text":"","category":"section"},{"location":"api/states/#Weighted-States","page":"States","title":"Weighted States","text":"","category":"section"},{"location":"api/states/#Superpositions","page":"States","title":"Superpositions","text":"","category":"section"},{"location":"api/states/#Composite-States","page":"States","title":"Composite States","text":"For multi-particle systems. ProductKet is order-independent (bosonic).","category":"section"},{"location":"api/states/#Utility-Functions","page":"States","title":"Utility Functions","text":"","category":"section"},{"location":"api/states/#Fock-States","page":"States","title":"Fock States","text":"Convenience constructors for number states:","category":"section"},{"location":"api/states/#Examples","page":"States","title":"Examples","text":"using QSymbolic\n\nH, Hb = HilbertSpace(:H, 2)\nZb = Basis(H, :z)\n\n# Create basis kets\nup = Ket(Zb, :â†‘)\ndown = Ket(Zb, :â†“)\n\n# Superposition\nplus = (up + down) / âˆš2\n\n# Adjoint gives bra\nup'  # â†’ âŸ¨â†‘|\n\n# Inner products\nup' * up    # â†’ 1\nup' * down  # â†’ 0\n\n# Tensor products (order-independent)\nH_A, Ba = HilbertSpace(:A, 2)\nH_B, Bb = HilbertSpace(:B, 2)\nÏˆ = Ket(Ba, :Ïˆ)\nÏ• = Ket(Bb, :Ï•)\nÏˆ âŠ— Ï• == Ï• âŠ— Ïˆ  # â†’ true\n\n# Symbolic indices\nn = Sym(:n, :nonnegative, :integer)\nF, Fb = FockSpace(:mode)\nket_n = Ket(Fb, n)  # |nâŸ©","category":"section"},{"location":"api/states/#QSymbolic.AbstractKet","page":"States","title":"QSymbolic.AbstractKet","text":"AbstractKet{basis}\n\nAbstract supertype for ket vectors |ÏˆâŸ© in a specific basis.\n\n\n\n\n\n","category":"type"},{"location":"api/states/#QSymbolic.AbstractBra","page":"States","title":"QSymbolic.AbstractBra","text":"AbstractBra{basis}\n\nAbstract supertype for bra vectors âŸ¨Ïˆ| in a specific basis.\n\n\n\n\n\n","category":"type"},{"location":"api/states/#QSymbolic.Ket","page":"States","title":"QSymbolic.Ket","text":"Ket{B<:AbstractBasis}(index)\nKet(basis, index)\n\nBasic ket state |indexâŸ© in a specific basis. This is the fundamental building block.\n\nNote: A basis is required. You must explicitly provide a basis object.\n\nIndex can be:\n\nA Symbol (e.g., :â†‘, :Ïˆ)\nAn Integer (e.g., 0, 1, 2 for Fock states)\nA symbolic expression (Sym, SymExpr)\nA tuple for multi-index (e.g., (:n, :m) or (0, 1) for composite bases)\n\nExamples\n\njulia> H = HilbertSpace(:H, 2);\n\njulia> Zb = Basis(H, :z);\n\njulia> up = Ket(Zb, :â†‘)   # |â†‘âŸ© in z-basis\n|â†‘âŸ©\n\njulia> Xb = Basis(H, :x);\n\njulia> Ïˆ = Ket(Xb, :Ïˆ)     # |ÏˆâŸ© in x-basis\n|ÏˆâŸ©\n\nSee also: Bra, Basis, WeightedKet, SumKet, ProductKet\n\n\n\n\n\n","category":"type"},{"location":"api/states/#QSymbolic.Bra","page":"States","title":"QSymbolic.Bra","text":"Bra{B<:AbstractBasis}(index)\nBra(basis, index)\n\nBasic bra state âŸ¨index| in a specific basis. Usually created via adjoint: ket'.\n\nNote: A basis is required. You must explicitly provide a basis object.\n\nSee also: Ket, Basis\n\n\n\n\n\n","category":"type"},{"location":"api/states/#QSymbolic.WeightedKet","page":"States","title":"QSymbolic.WeightedKet","text":"WeightedKet{B<:AbstractBasis, T}(ket, weight)\n\nA ket (Ket or ProductKet) multiplied by a scalar weight. Created automatically via scalar multiplication: weight * ket.\n\nExamples\n\njulia> _, Hb = HilbertSpace(:H, 2);\n\njulia> Ïˆ = Ket(Hb, :Ïˆ);\n\njulia> 2 * Ïˆ\n2Â·|ÏˆâŸ©\n\nSee also: Ket, SumKet\n\n\n\n\n\n","category":"type"},{"location":"api/states/#QSymbolic.WeightedBra","page":"States","title":"QSymbolic.WeightedBra","text":"WeightedBra{B,T}(bra, weight)\n\nA bra multiplied by a scalar weight. Created via adjoint of WeightedKet (with complex conjugate weight).\n\nSee also: WeightedKet\n\n\n\n\n\n","category":"type"},{"location":"api/states/#QSymbolic.SumKet","page":"States","title":"QSymbolic.SumKet","text":"SumKet{B<:AbstractBasis, T}(kets, weights; name=nothing)\n\nLinear combination of kets with weights: Î£áµ¢ wáµ¢|Ïˆáµ¢âŸ©. Created automatically via addition/subtraction of kets.\n\nThe kets can be either Ket or ProductKet (but all must share the same basis structure).\n\nExamples\n\njulia> _, Hb = HilbertSpace(:H, 2);\n\njulia> Ïˆ, Ï• = Ket(Hb, :Ïˆ), Ket(Hb, :Ï•);\n\njulia> Ïˆ + Ï•\n|ÏˆâŸ© + |Ï•âŸ©\n\njulia> (Ïˆ + Ï•) / âˆš2\n0.7071067811865475Â·|ÏˆâŸ© + 0.7071067811865475Â·|Ï•âŸ©\n\nSee also: Ket, WeightedKet\n\n\n\n\n\n","category":"type"},{"location":"api/states/#QSymbolic.SumBra","page":"States","title":"QSymbolic.SumBra","text":"SumBra{B,T}(bras, weights; name=nothing)\n\nLinear combination of bras with weights. Created via adjoint of SumKet (with complex conjugate weights).\n\nSee also: SumKet\n\n\n\n\n\n","category":"type"},{"location":"api/states/#QSymbolic.ProductKet","page":"States","title":"QSymbolic.ProductKet","text":"ProductKet{Bs<:Tuple}(kets::Vector{Ket})\nProductKet(ket1, ket2, ...)\n\nTensor product of kets: |Ïˆâ‚âŸ©âŠ—|Ïˆâ‚‚âŸ©âŠ—...âŠ—|Ïˆâ‚™âŸ©. Lives in a CompositeBasis. This is a container struct (like SumKet), not a basic element - only Ket is a basic element.\n\nNote: ProductKets are order-independent (bosonic/symmetric). The kets are canonically ordered by basis, so k1 âŠ— k2 == k2 âŠ— k1 when they have different bases. This is the default behavior; fermionic (anti-symmetric) tensor products will be added in a future update.\n\nThe tensor product operator âŠ— creates ProductKets automatically.\n\nExamples\n\njulia> _, B1 = HilbertSpace(:A, 2); _, B2 = HilbertSpace(:B, 2);\n\njulia> Ïˆ, Ï• = Ket(B1, :Ïˆ), Ket(B2, :Ï•);\n\njulia> Ïˆ âŠ— Ï•\n|ÏˆâŸ©âŠ—|Ï•âŸ©\n\njulia> Ï• âŠ— Ïˆ == Ïˆ âŠ— Ï•  # Order-independent (bosonic)\ntrue\n\njulia> _, B3 = HilbertSpace(:C, 2);\n\njulia> Ï‡ = Ket(B3, :Ï‡);\n\njulia> Ïˆ âŠ— Ï• âŠ— Ï‡  # Three kets\n|ÏˆâŸ©âŠ—|Ï•âŸ©âŠ—|Ï‡âŸ©\n\nSee also: Ket, âŠ—\n\n\n\n\n\n","category":"type"},{"location":"api/states/#QSymbolic.ProductBra","page":"States","title":"QSymbolic.ProductBra","text":"ProductBra{Bs<:Tuple}(bras::Vector{Bra})\nProductBra(bra1, bra2, ...)\n\nTensor product of bras: âŸ¨Ïˆâ‚|âŠ—âŸ¨Ïˆâ‚‚|âŠ—...âŠ—âŸ¨Ïˆâ‚™|. Created via adjoint of ProductKet.\n\nNote: ProductBras are order-independent (bosonic/symmetric), matching the behavior of ProductKet.\n\nSee also: ProductKet, Bra\n\n\n\n\n\n","category":"type"},{"location":"api/states/#QSymbolic.FockKet","page":"States","title":"QSymbolic.FockKet","text":"FockKet(space::HilbertSpace, n::Int)\n\nCreate a Fock state |nâŸ© in the given infinite-dimensional Hilbert space. Uses a default :n basis for the Fock space.\n\nSee also: Ket, FockBra\n\n\n\n\n\n","category":"function"},{"location":"api/states/#QSymbolic.FockBra","page":"States","title":"QSymbolic.FockBra","text":"FockBra(space::HilbertSpace, n::Int)\n\nCreate a Fock bra âŸ¨n| in the given infinite-dimensional Hilbert space. Uses a default :n basis for the Fock space.\n\nSee also: Bra, FockKet\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#Operators","page":"Operators","title":"Operators","text":"Quantum operators transform states and are essential for describing observables and dynamics. QSymbolic.jl provides outer product operators, operator algebra, and function-defined operators.","category":"section"},{"location":"api/operators/#Overview","page":"Operators","title":"Overview","text":"Type Description\nOuter Single outer product |ÏˆâŸ©âŸ¨Ï•|\nOperator Sum of weighted outer products\nIdentity Identity operator ð•€\nFunctionOperator Operator defined by a function","category":"section"},{"location":"api/operators/#Abstract-Type","page":"Operators","title":"Abstract Type","text":"","category":"section"},{"location":"api/operators/#Outer-Product-Operator","page":"Operators","title":"Outer Product Operator","text":"The primary way to build operators from states:","category":"section"},{"location":"api/operators/#Operator-Container","page":"Operators","title":"Operator Container","text":"Sum of weighted outer products:","category":"section"},{"location":"api/operators/#Identity-Operator","page":"Operators","title":"Identity Operator","text":"","category":"section"},{"location":"api/operators/#Function-Based-Operator","page":"Operators","title":"Function-Based Operator","text":"For operators with procedural definitions (e.g., Fock space ladder operators):","category":"section"},{"location":"api/operators/#FunctionOperator-Syntax","page":"Operators","title":"FunctionOperator Syntax","text":"# Basic usage\naction(ket::Ket{B}) where B = ...  # returns AbstractKet or Number\nop = FunctionOperator(action, basis, name=:op)\n\n# With adjoint action\nop = FunctionOperator(action, basis, adjoint_action=adj_action, name=:op)\n\n# Do-block syntax\nop = FunctionOperator(basis, name=:op) do ket\n    # action on ket\nend","category":"section"},{"location":"api/operators/#Accessor-Functions","page":"Operators","title":"Accessor Functions","text":"","category":"section"},{"location":"api/operators/#Examples","page":"Operators","title":"Examples","text":"","category":"section"},{"location":"api/operators/#Projectors-and-Ladder-Operators","page":"Operators","title":"Projectors and Ladder Operators","text":"using QSymbolic\n\nH, Hb = HilbertSpace(:spin, 2)\nZb = Basis(H, :z)\nup = Ket(Zb, :â†‘)\ndown = Ket(Zb, :â†“)\n\n# Projector\nP_up = up * up'  # |â†‘âŸ©âŸ¨â†‘|\nP_up * up   # â†’ |â†‘âŸ©\nP_up * down # â†’ 0\n\n# Ladder operator\nÏƒ_plus = up * down'  # |â†‘âŸ©âŸ¨â†“|\nÏƒ_plus * down  # â†’ |â†‘âŸ©\n\n# Operator sum\nÏƒz = up * up' - down * down'","category":"section"},{"location":"api/operators/#Fock-Space-Operators","page":"Operators","title":"Fock Space Operators","text":"using QSymbolic\n\nF, Fb = FockSpace(:mode)\n\n# Annihilation operator: Ã¢|nâŸ© = âˆšn |n-1âŸ©\nannihilate(ket::Ket{B}) where B = âˆš(ket.index) * Ket{B}(ket.index - 1)\ncreate(ket::Ket{B}) where B = âˆš(ket.index + 1) * Ket{B}(ket.index + 1)\n\nÃ¢ = FunctionOperator(annihilate, Fb, adjoint_action=create, name=:Ã¢)\n\n# Apply to symbolic Fock state\nn = Sym(:n, :nonnegative, :integer)\nket_n = Ket(Fb, n)\nÃ¢ * ket_n   # â†’ âˆšn |n-1âŸ©\nÃ¢' * ket_n  # â†’ âˆš(n+1) |n+1âŸ©","category":"section"},{"location":"api/operators/#QSymbolic.AbstractOperator","page":"Operators","title":"QSymbolic.AbstractOperator","text":"AbstractOperator{S}\n\nAbstract supertype for all quantum operators acting on space S. Operators use bra-ket arithmetic for contraction.\n\nThe type parameter S is typically an AbstractSpace subtype, but can also be  Nothing for space-agnostic lazy containers like OperatorProduct.\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#QSymbolic.Outer","page":"Operators","title":"QSymbolic.Outer","text":"Outer{S<:AbstractSpace}(ket, bra)\nket * bra'  (automatically creates Outer)\n\nBasic outer product operator |ÏˆâŸ©âŸ¨Ï•|. Allows cross-basis operators where the ket and bra can be in different bases, as long as they're in the same space.\n\nApplication uses bra-ket contraction:     (|ÏˆâŸ©âŸ¨Ï•|)|Ï‡âŸ© = âŸ¨Ï•|Ï‡âŸ© |ÏˆâŸ©\n\nExamples\n\nH, Hb = HilbertSpace(:H, 2)\nup = Ket(Hb, :â†‘)\ndown = Ket(Hb, :â†“)\n\n# Projector onto |â†‘âŸ©\nP_up = up * up'  # |â†‘âŸ©âŸ¨â†‘|\n\n# Apply: P_up|â†‘âŸ© = |â†‘âŸ©, P_up|â†“âŸ© = 0\nP_up * up   # â†’ |â†‘âŸ©\nP_up * down # â†’ 0\n\n# Ladder operator |â†‘âŸ©âŸ¨â†“|\nÏƒ_plus = up * down'\nÏƒ_plus * down  # â†’ |â†‘âŸ©\n\nSee also: Operator, Identity, FunctionOperator\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#QSymbolic.Operator","page":"Operators","title":"QSymbolic.Operator","text":"Operator{S<:AbstractSpace}(outers, weights)\n\nContainer type representing a sum of weighted outer products:     Î£áµ¢ wáµ¢ |Ïˆáµ¢âŸ©âŸ¨Ï•áµ¢|\n\nApplication decomposes to bra-ket arithmetic:     (Î£áµ¢ wáµ¢ |Ïˆáµ¢âŸ©âŸ¨Ï•áµ¢|)|Ï‡âŸ© = Î£áµ¢ wáµ¢ âŸ¨Ï•áµ¢|Ï‡âŸ© |Ïˆáµ¢âŸ©\n\nExamples\n\nH, Hb = HilbertSpace(:H, 2)\nup = Ket(Hb, :â†‘)\ndown = Ket(Hb, :â†“)\n\n# Ïƒ_x = |â†‘âŸ©âŸ¨â†“| + |â†“âŸ©âŸ¨â†‘|\nÏƒ_x = Operator([Outer(up, down'), Outer(down, up')], [1, 1])\n\n# Or construct from arithmetic\nÏƒ_x = up * down' + down * up'\n\nSee also: Outer, Identity\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#QSymbolic.Identity","page":"Operators","title":"QSymbolic.Identity","text":"Identity{S<:AbstractSpace}(space)\n\nThe identity operator on space S. Basis-independent.\n\nExamples\n\nH, Hb = HilbertSpace(:H, 2)\nI = Identity(H)\n\nÏˆ = Ket(Hb, :Ïˆ)\nI * Ïˆ  # â†’ |ÏˆâŸ©\n\nSee also: Operator, Outer\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#QSymbolic.FunctionOperator","page":"Operators","title":"QSymbolic.FunctionOperator","text":"FunctionOperator{S<:AbstractSpace, B<:AbstractBasis}(basis, action; adjoint_action=nothing, name=:F)\nFunctionOperator(basis) do ket ... end\n\nFunction-based operator that applies a user-defined function to kets in a specific basis. The function receives a ket in the operator's basis and returns any AbstractKet.\n\nIf the input ket is in a different basis, the operator automatically applies a basis transform before applying the action (if a transform is defined).\n\nConstructed with do-block syntax:\n\nF_op = FunctionOperator(basis) do ket\n    # Process ket in 'basis', return AbstractKet or Number\n    ...\nend\n\nOptionally provide adjoint_action for the adjoint operator and name for display.\n\nExamples\n\nF, Fb = HilbertSpace(:Fock, Inf)\n\n# Annihilation operator: Ã¢|nâŸ© = âˆšn |n-1âŸ©\nÃ¢ = FunctionOperator(Fb) do ket\n    n = parse(Int, string(ket.index))\n    n == 0 ? 0 : âˆšn * Ket(Fb, n - 1)\nend\n\n# With adjoint (creation operator):\nÃ¢ = FunctionOperator(Fb; \n    adjoint_action = ket -> begin\n        n = parse(Int, string(ket.index))\n        âˆš(n + 1) * Ket(Fb, n + 1)\n    end,\n    name = :Ã¢\n) do ket\n    n = parse(Int, string(ket.index))\n    n == 0 ? 0 : âˆšn * Ket(Fb, n - 1)\nend\n\n# Cross-basis: if ket is in different basis, transform is applied first\nFb2 = Basis(F, :energy)\n# Define transform between bases first\ndefine_transform!(typeof(Fb2), typeof(Fb)) do k\n    # ... transformation logic ...\nend\nÃ¢ * Ket(Fb2, :E0)  # Transforms to Fb basis first, then applies Ã¢\n\nSee also: Operator, Outer, define_transform!\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#QSymbolic.space-Tuple{AbstractOperator}","page":"Operators","title":"QSymbolic.space","text":"space(basis)\nspace(ket_or_bra)\nspace(operator)\n\nGet the underlying Hilbert space of a basis, ket, bra, or operator.\n\n\n\n\n\n","category":"method"},{"location":"guide/composite/#Composite-Systems","page":"Composite Systems","title":"Composite Systems","text":"QSymbolic.jl supports tensor products for multi-particle quantum systems, with automatic factorization of basis transforms.","category":"section"},{"location":"guide/composite/#Tensor-Product-of-Spaces","page":"Composite Systems","title":"Tensor Product of Spaces","text":"Combine Hilbert spaces with the tensor product operator âŠ—:\n\nusing QSymbolic\n\nH_A = HilbertSpace(:A, 2)  # First qubit\nH_B = HilbertSpace(:B, 2)  # Second qubit\n\nH_AB = H_A âŠ— H_B  # 4-dimensional composite space\n\nThe resulting CompositeSpace represents the joint system.","category":"section"},{"location":"guide/composite/#Product-States","page":"Composite Systems","title":"Product States","text":"Create tensor products of kets for separable (non-entangled) states:\n\nH_A, Ba = HilbertSpace(:A, 2)\nH_B, Bb = HilbertSpace(:B, 2)\n\nÏˆ_A = Ket(Ba, :Ïˆ)\nÏ•_B = Ket(Bb, :Ï•)\n\nproduct = Ïˆ_A âŠ— Ï•_B  # |ÏˆâŸ©_A âŠ— |Ï•âŸ©_B (ProductKet)\n\nThis represents a state where subsystem A is in state |ÏˆâŸ© and subsystem B is in state |Ï•âŸ©, with no correlations between them.","category":"section"},{"location":"guide/composite/#Order-Independent-(Bosonic)-Behavior","page":"Composite Systems","title":"Order-Independent (Bosonic) Behavior","text":"note: ProductKet Ordering\nProductKets are order-independent (bosonic/symmetric). The kets are canonically ordered by basis, so Ïˆ_A âŠ— Ï•_B == Ï•_B âŠ— Ïˆ_A when they have different bases. This is the default behavior.\n\nH_A, Ba = HilbertSpace(:A, 2)\nH_B, Bb = HilbertSpace(:B, 2)\n\nÏˆ = Ket(Ba, :Ïˆ)\nÏ• = Ket(Bb, :Ï•)\n\n# Order doesn't matter for different bases\nÏˆ âŠ— Ï• == Ï• âŠ— Ïˆ  # â†’ true\n\n# Three-way tensor products also canonicalize\nH_C, Bc = HilbertSpace(:C, 2)\nÏ‡ = Ket(Bc, :Ï‡)\n\nÏˆ âŠ— Ï• âŠ— Ï‡ == Ï‡ âŠ— Ïˆ âŠ— Ï•  # â†’ true\n\nwarning: Future Feature\nFermionic (anti-symmetric) tensor products will be added in a future update.","category":"section"},{"location":"guide/composite/#Inner-Products-of-Product-States","page":"Composite Systems","title":"Inner Products of Product States","text":"Inner products of product states factorize:\n\n(Ïˆ_A  Ï•_B)(Ïˆ_A  Ï•_B) = Ïˆ_AÏˆ_A cdot Ï•_BÏ•_B\n\nproduct' * product  # â†’ 1 Ã— 1 = 1\n\n# Different states\nÏ‡_A = Ket(Ba, :Ï‡)\nother = Ï‡_A âŠ— Ï•_B\n\nproduct' * other    # â†’ âŸ¨Ïˆ|Ï‡âŸ© Ã— âŸ¨Ï•|Ï•âŸ© = 0 Ã— 1 = 0","category":"section"},{"location":"guide/composite/#Multi-Index-Kets","page":"Composite Systems","title":"Multi-Index Kets","text":"For composite systems, you can also use multi-index kets with a composite basis:\n\nS_cavity, B_cavity = FockSpace(:cavity)\nS_dot, B_dot = HilbertSpace(:dot, 3)\n\n# Create composite space and basis\nS_system = S_cavity âŠ— S_dot\nB_composite = Basis(S_system, :dressed)\n\n# Multi-index ket: |n, ÏƒâŸ©\nket = Ket(B_composite, (Sym(:n), Sym(:Ïƒ)))\n\n# Inner products check all indices\nket' * ket  # â†’ 1\n\nThis is useful for dressed states like Jaynes-Cummings eigenstates. See Custom Contraction Rules for defining custom inner product behavior.","category":"section"},{"location":"guide/composite/#Composite-Bases","page":"Composite Systems","title":"Composite Bases","text":"Combine bases into a composite basis:\n\nH_A = HilbertSpace(:A, 2)\nH_B = HilbertSpace(:B, 2)\n\nZa = Basis(H_A, :z)\nZb = Basis(H_B, :z)\n\nZaZb = Za âŠ— Zb  # CompositeBasis for the joint system","category":"section"},{"location":"guide/composite/#Factorized-Transforms","page":"Composite Systems","title":"Factorized Transforms","text":"Transforms factorize automatically. If you define:\n\nTransform from Xa â†’ Za (for subsystem A)\nTransform from Xb â†’ Zb (for subsystem B)\n\nThen the composite transform XaâŠ—Xb â†’ ZaâŠ—Zb is derived automatically!\n\nH_A = HilbertSpace(:A, 2)\nH_B = HilbertSpace(:B, 2)\n\n# Define bases\nZa, Xa = Basis(H_A, :z), Basis(H_A, :x)\nZb, Xb = Basis(H_B, :z), Basis(H_B, :x)\n\n# Create states\nup_a, down_a = Ket(Za, :â†‘), Ket(Za, :â†“)\nup_b, down_b = Ket(Zb, :â†‘), Ket(Zb, :â†“)\n\n# Define subsystem transforms\ndefine_transform!(Xa, Za) do idx\n    idx == :â†‘ ? (up_a + down_a)/âˆš2 : (up_a - down_a)/âˆš2\nend\ndefine_transform!(Xb, Zb) do idx\n    idx == :â†‘ ? (up_b + down_b)/âˆš2 : (up_b - down_b)/âˆš2\nend\n\n# Product state in xâŠ—x basis\nup_x_a = Ket(Xa, :â†‘)\nup_x_b = Ket(Xb, :â†‘)\nstate_xx = up_x_a âŠ— up_x_b\n\n# Transform to zâŠ—z - automatically factorized!\ntarget_basis = typeof(Za âŠ— Zb)\nstate_zz = transform(state_xx, target_basis)\n# Result: (|â†‘â†‘âŸ© + |â†‘â†“âŸ© + |â†“â†‘âŸ© + |â†“â†“âŸ©)/2","category":"section"},{"location":"guide/composite/#Entangled-States","page":"Composite Systems","title":"Entangled States","text":"Entangled states are superpositions of product states:\n\nH = HilbertSpace(:qubit, 2)\nZ = Basis(H, :z)\n\nup = Ket(Z, :0)\ndown = Ket(Z, :1)\n\n# Bell state |Î¦âºâŸ© = (|00âŸ© + |11âŸ©)/âˆš2\nzero_zero = up âŠ— up\none_one = down âŠ— down\n\nbell_plus = (zero_zero + one_one) / âˆš2","category":"section"},{"location":"guide/composite/#Operators-on-Composite-Systems","page":"Composite Systems","title":"Operators on Composite Systems","text":"","category":"section"},{"location":"guide/composite/#Tensor-Product-of-Operators","page":"Composite Systems","title":"Tensor Product of Operators","text":"H_A, Ba = HilbertSpace(:A, 2)\nH_B, Bb = HilbertSpace(:B, 2)\nZa = Basis(H_A, :z)\nZb = Basis(H_B, :z)\n\nup_a, down_a = Ket(Za, :â†‘), Ket(Za, :â†“)\nup_b, down_b = Ket(Zb, :â†‘), Ket(Zb, :â†“)\n\n# Single-qubit operators\nÏƒz_a = up_a * up_a' - down_a * down_a'\nÏƒz_b = up_b * up_b' - down_b * down_b'\n\n# Tensor product: Ïƒz_A âŠ— Ïƒz_B\nÏƒz_ab = Ïƒz_a âŠ— Ïƒz_b\n\n# Apply to product state\nÏˆ = up_a âŠ— up_b\nÏƒz_ab * Ïˆ  # â†’ |â†‘â†‘âŸ© (eigenvalue +1)","category":"section"},{"location":"guide/composite/#Single-System-Operators-on-Product-States","page":"Composite Systems","title":"Single-System Operators on Product States","text":"Operators automatically act on their matching subsystem:\n\nS_cavity, B_cavity = FockSpace(:cavity)\nS_dot, B_dot = HilbertSpace(:dot, 3)\n\n# Annihilation operator on cavity\nannihilate(ket::Ket{B}) where B = âˆš(ket.index) * Ket{B}(ket.index - 1)\na = FunctionOperator(annihilate, B_cavity, name=:a)\n\n# Apply to product state\nd = Sym(:d)\nproduct_state = Ket(B_cavity, d) âŠ— Ket(B_dot, :g)\n\na * product_state  # â†’ âˆšd |d-1âŸ© âŠ— |gâŸ©","category":"section"},{"location":"guide/composite/#See-Also","page":"Composite Systems","title":"See Also","text":"Basis Transforms - Cross-basis computations\nOperators - Operator algebra\nCustom Contraction Rules - Multi-index inner products","category":"section"},{"location":"guide/operators/#Operators","page":"Operators","title":"Operators","text":"QSymbolic.jl provides a comprehensive system for quantum operators, including outer product operators, operator algebra, and function-defined operators.","category":"section"},{"location":"guide/operators/#Outer-Product-Operators","page":"Operators","title":"Outer Product Operators","text":"The most natural way to build quantum operators is via outer products |ÏˆâŸ©âŸ¨Ï•|. When applied to a state:\n\n(ÏˆÏ•)Ï‡ = Ï•Ï‡ Ïˆ\n\nusing QSymbolic\n\nH = HilbertSpace(:spin, 2)\nZb = Basis(H, :z)\n\nup = Ket(Zb, :â†‘)\ndown = Ket(Zb, :â†“)\n\n# Create operator via outer product\nP_up = up * up'      # |â†‘âŸ©âŸ¨â†‘|\n\n# Display shows Dirac notation\nP_up  # â†’ |â†‘âŸ©âŸ¨â†‘|\n\n# Apply to states\nP_up * up    # â†’ |â†‘âŸ© (eigenstate)\nP_up * down  # â†’ 0   (orthogonal)","category":"section"},{"location":"guide/operators/#Projectors","page":"Operators","title":"Projectors","text":"A projector onto state |ÏˆâŸ© is P = |ÏˆâŸ©âŸ¨Ïˆ|. It satisfies:\n\nP|ÏˆâŸ© = |ÏˆâŸ© (leaves the state unchanged)\nP|Ï•âŸ© = 0 for orthogonal states\nPÂ² = P (idempotent)\n\n# Projector onto |â†‘âŸ©\nP_up = up * up'\n\nP_up * up                # â†’ |â†‘âŸ©\nP_up * down              # â†’ 0\n(P_up * P_up) * up       # â†’ |â†‘âŸ© (PÂ² = P)","category":"section"},{"location":"guide/operators/#Ladder-(Raising/Lowering)-Operators","page":"Operators","title":"Ladder (Raising/Lowering) Operators","text":"Operators like |â†‘âŸ©âŸ¨â†“| raise or lower states:\n\n# Raising operator Ïƒâ‚Š = |â†‘âŸ©âŸ¨â†“|\nÏƒ_plus = up * down'\n\nÏƒ_plus * down  # â†’ |â†‘âŸ© (raises |â†“âŸ© to |â†‘âŸ©)\nÏƒ_plus * up    # â†’ 0   (can't raise |â†‘âŸ© further)\n\n# Lowering operator Ïƒâ‚‹ = |â†“âŸ©âŸ¨â†‘| = (Ïƒâ‚Š)â€ \nÏƒ_minus = Ïƒ_plus'\n\nÏƒ_minus * up    # â†’ |â†“âŸ©\nÏƒ_minus * down  # â†’ 0","category":"section"},{"location":"guide/operators/#Operator-Algebra","page":"Operators","title":"Operator Algebra","text":"Operators can be combined using standard arithmetic:","category":"section"},{"location":"guide/operators/#Addition-and-Subtraction","page":"Operators","title":"Addition and Subtraction","text":"P_up = up * up'\nP_down = down * down'\n\n# Identity operator: ð•€ = |â†‘âŸ©âŸ¨â†‘| + |â†“âŸ©âŸ¨â†“|\nI = P_up + P_down\n\nI * up    # â†’ |â†‘âŸ©\nI * down  # â†’ |â†“âŸ©\n\n# Pauli Z: Ïƒz = |â†‘âŸ©âŸ¨â†‘| - |â†“âŸ©âŸ¨â†“|\nÏƒz = P_up - P_down\n\nÏƒz * up    # â†’ |â†‘âŸ©  (eigenvalue +1)\nÏƒz * down  # â†’ -|â†“âŸ© (eigenvalue -1)","category":"section"},{"location":"guide/operators/#Scalar-Multiplication","page":"Operators","title":"Scalar Multiplication","text":"# Scale an operator\nhalf_Ïƒz = (1/2) * Ïƒz\n\nhalf_Ïƒz * up  # â†’ 0.5|â†‘âŸ©","category":"section"},{"location":"guide/operators/#Operator-Products","page":"Operators","title":"Operator Products","text":"# Product of operators: (Ã‚BÌ‚)|ÏˆâŸ© = Ã‚(BÌ‚|ÏˆâŸ©)\nÏƒ_plus = up * down'\nÏƒ_minus = down * up'\n\n# Ïƒâ‚ŠÏƒâ‚‹ = |â†‘âŸ©âŸ¨â†“|â†“âŸ©âŸ¨â†‘| = |â†‘âŸ©âŸ¨â†‘|\nproduct = Ïƒ_plus * Ïƒ_minus\n\nproduct * up    # â†’ |â†‘âŸ©\nproduct * down  # â†’ 0","category":"section"},{"location":"guide/operators/#Adjoint-(Hermitian-Conjugate)","page":"Operators","title":"Adjoint (Hermitian Conjugate)","text":"The adjoint of |ÏˆâŸ©âŸ¨Ï•| is |Ï•âŸ©âŸ¨Ïˆ|:\n\nA = up * down'   # |â†‘âŸ©âŸ¨â†“|\nA'               # â†’ |â†“âŸ©âŸ¨â†‘|\n\nFor sum operators, the adjoint distributes:\n\nÏƒz = P_up - P_down\nÏƒz'  # â†’ |â†‘âŸ©âŸ¨â†‘| - |â†“âŸ©âŸ¨â†“| (Ïƒz is Hermitian)","category":"section"},{"location":"guide/operators/#Applying-Operators-to-Superpositions","page":"Operators","title":"Applying Operators to Superpositions","text":"Operators act linearly on superpositions:\n\n# Superposition |ÏˆâŸ© = (|â†‘âŸ© + |â†“âŸ©)/âˆš2\nÏˆ = (up + down) / âˆš2\n\n# Ïƒz|ÏˆâŸ© = (|â†‘âŸ© - |â†“âŸ©)/âˆš2\nÏƒz * Ïˆ  # â†’ 0.707|â†‘âŸ© - 0.707|â†“âŸ©","category":"section"},{"location":"guide/operators/#Function-Based-Operators","page":"Operators","title":"Function-Based Operators","text":"For operators with complex or infinite-dimensional action (like ladder operators in Fock space), use FunctionOperator. This is particularly useful when:\n\nThe action depends on the state label (like Fock space number)\nThe space is infinite-dimensional\nThe transformation is more naturally expressed procedurally","category":"section"},{"location":"guide/operators/#Basic-Syntax","page":"Operators","title":"Basic Syntax","text":"F, Fb = FockSpace(:mode)\n\n# Define action function\nannihilate(ket::Ket{B}) where B = âˆš(ket.index) * Ket{B}(ket.index - 1)\n\n# Create function operator\nÃ¢ = FunctionOperator(annihilate, Fb, name=:Ã¢)\n\n# Apply to Fock states\nn3 = Ket(Fb, 3)\nÃ¢ * n3  # â†’ âˆš3 |2âŸ©\n\nn0 = Ket(Fb, 0)\nÃ¢ * n0  # â†’ 0 (vacuum annihilated)","category":"section"},{"location":"guide/operators/#With-Do-Block-Syntax","page":"Operators","title":"With Do-Block Syntax","text":"F, Fb = FockSpace(:mode)\n\n# Using do-block\nÃ¢ = FunctionOperator(Fb, name=:Ã¢) do ket\n    n = ket.index\n    n == 0 ? 0 : âˆšn * Ket{typeof(Fb)}(n - 1)\nend","category":"section"},{"location":"guide/operators/#With-Adjoint-Action","page":"Operators","title":"With Adjoint Action","text":"For operators where you also need the adjoint (like creation operator for annihilation):\n\nF, Fb = FockSpace(:mode)\n\n# Define both actions\nannihilate(ket::Ket{B}) where B = âˆš(ket.index) * Ket{B}(ket.index - 1)\ncreate(ket::Ket{B}) where B = âˆš(ket.index + 1) * Ket{B}(ket.index + 1)\n\n# Create with adjoint\nÃ¢ = FunctionOperator(annihilate, Fb, adjoint_action=create, name=:Ã¢)\n\n# Now adjoint works\nÃ¢'  # Creation operator Ã¢â€ \n\n# Verify Ã¢â€ Ã¢|nâŸ© = n|nâŸ© (number operator)\nn = Sym(:n, :nonnegative, :integer)\nket_n = Ket(Fb, n)\nÃ¢' * (Ã¢ * ket_n)  # â†’ n|nâŸ©","category":"section"},{"location":"guide/operators/#Working-with-Symbolic-Indices","page":"Operators","title":"Working with Symbolic Indices","text":"Function operators work seamlessly with symbolic indices:\n\nF, Fb = FockSpace(:mode)\n\n# Action handles symbolic indices\nannihilate(ket::Ket{B}) where B = âˆš(ket.index) * Ket{B}(ket.index - 1)\nÃ¢ = FunctionOperator(annihilate, Fb, name=:Ã¢)\n\n# Symbolic index\nd = Sym(:d, :nonnegative, :integer)\nket_d = Ket(Fb, d)\n\nÃ¢ * ket_d  # â†’ âˆšd |d-1âŸ©","category":"section"},{"location":"guide/operators/#Operators-on-Composite-States","page":"Operators","title":"Operators on Composite States","text":"Function operators automatically handle tensor products:\n\nS_cavity, B_cavity = FockSpace(:cavity)\nS_dot, B_dot = HilbertSpace(:dot, 3)\n\n# Annihilation operator on cavity\nannihilate(ket::Ket{B}) where B = âˆš(ket.index) * Ket{B}(ket.index - 1)\na = FunctionOperator(annihilate, B_cavity, name=:a)\n\n# Apply to product state |dâŸ© âŠ— |gâŸ©\nd = Sym(:d)\nproduct_state = Ket(B_cavity, d) âŠ— Ket(B_dot, :g)\n\na * product_state  # â†’ âˆšd |d-1âŸ© âŠ— |gâŸ©","category":"section"},{"location":"guide/operators/#Identity-Operator","page":"Operators","title":"Identity Operator","text":"H = HilbertSpace(:H, 2)\n\n# Create identity on a space\nI = Identity(H)\n\nH, Hb = HilbertSpace(:H, 2)\nÏˆ = Ket(Hb, :Ïˆ)\nI * Ïˆ  # â†’ |ÏˆâŸ©","category":"section"},{"location":"guide/operators/#Operator-Types-Summary","page":"Operators","title":"Operator Types Summary","text":"Type Description Example\nOuter Single outer product |ÏˆâŸ©âŸ¨Ï•| up * down'\nOperator Sum of weighted outers Ïƒz = P_up - P_down\nIdentity Identity on space Identity(H)\nFunctionOperator User-defined action FunctionOperator(action, basis)","category":"section"},{"location":"guide/operators/#Complete-Example:-Pauli-Matrices","page":"Operators","title":"Complete Example: Pauli Matrices","text":"using QSymbolic\n\nH = HilbertSpace(:spin, 2)\nZb = Basis(H, :z)\n\nup = Ket(Zb, :â†‘)\ndown = Ket(Zb, :â†“)\n\n# Build Pauli matrices from outer products\nÏƒx = up * down' + down * up'         # |â†‘âŸ©âŸ¨â†“| + |â†“âŸ©âŸ¨â†‘|\nÏƒy = -im * up * down' + im * down * up'  # -i|â†‘âŸ©âŸ¨â†“| + i|â†“âŸ©âŸ¨â†‘|\nÏƒz = up * up' - down * down'         # |â†‘âŸ©âŸ¨â†‘| - |â†“âŸ©âŸ¨â†“|\n\n# Verify eigenvalues\nÏƒz * up    # â†’ |â†‘âŸ©   (eigenvalue +1)\nÏƒz * down  # â†’ -|â†“âŸ©  (eigenvalue -1)\n\nÏƒx * up    # â†’ |â†“âŸ©\nÏƒx * down  # â†’ |â†‘âŸ©\n\n# Apply to superposition\nÏˆ = (up + down) / âˆš2\nÏƒz * Ïˆ     # â†’ (|â†‘âŸ© - |â†“âŸ©)/âˆš2","category":"section"},{"location":"guide/operators/#Complete-Example:-Fock-Space-Ladder-Operators","page":"Operators","title":"Complete Example: Fock Space Ladder Operators","text":"using QSymbolic\n\nF, Fb = FockSpace(:mode)\n\n# Define annihilation and creation\nannihilate(ket::Ket{B}) where B = âˆš(ket.index) * Ket{B}(ket.index - 1)\ncreate(ket::Ket{B}) where B = âˆš(ket.index + 1) * Ket{B}(ket.index + 1)\n\nÃ¢ = FunctionOperator(annihilate, Fb, adjoint_action=create, name=:Ã¢)\nÃ¢â€  = Ã¢'\n\n# Number operator NÌ‚ = Ã¢â€ Ã¢\n# Apply to |nâŸ©\nn = Sym(:n, :nonnegative, :integer)\nket_n = Ket(Fb, n)\n\nÃ¢ * ket_n       # â†’ âˆšn |n-1âŸ©\nÃ¢â€  * ket_n      # â†’ âˆš(n+1) |n+1âŸ©\nÃ¢â€  * (Ã¢ * ket_n)  # â†’ n|nâŸ© (eigenvalue equation)","category":"section"},{"location":"guide/operators/#See-Also","page":"Operators","title":"See Also","text":"Getting Started - Basic quantum state operations\nComposite Systems - Operators on tensor products\nBasis Transforms - Cross-basis operator application","category":"section"},{"location":"api/symbolic/#Symbolic-Scalars","page":"Symbolic Scalars","title":"Symbolic Scalars","text":"QSymbolic.jl uses Symbolics.jl as its backend for symbolic computation.","category":"section"},{"location":"api/symbolic/#Overview","page":"Symbolic Scalars","title":"Overview","text":"Type/Function Description\nAbstractSymbolic Type alias for Symbolics.jl types\nSym Create symbolic variable with assumptions\n@variables, @syms Re-exported from Symbolics.jl\nKroneckerDelta Kronecker delta Î´áµ¢â±¼\nsubstitute Replace symbols with values\nevaluate Compute numeric result\nsimplify Algebraic simplification","category":"section"},{"location":"api/symbolic/#Types","page":"Symbolic Scalars","title":"Types","text":"","category":"section"},{"location":"api/symbolic/#AbstractSymbolic","page":"Symbolic Scalars","title":"AbstractSymbolic","text":"Type alias for symbolic types:\n\nconst AbstractSymbolic = Union{Symbolics.Num, Complex{Symbolics.Num}}","category":"section"},{"location":"api/symbolic/#Symbolic-Variable","page":"Symbolic Scalars","title":"Symbolic Variable","text":"","category":"section"},{"location":"api/symbolic/#Kronecker-Delta","page":"Symbolic Scalars","title":"Kronecker Delta","text":"","category":"section"},{"location":"api/symbolic/#Creating-Variables","page":"Symbolic Scalars","title":"Creating Variables","text":"# QSymbolic API\nn = Sym(:n)                        # Default (real)\nm = Sym(:m, :integer)              # With assumption\nÎ¸ = Sym(:Î¸, :real, :positive)      # Multiple assumptions\n\n# Symbolics.jl macros (re-exported)\n@variables x y z\n@syms a b c\n@variables n::Integer","category":"section"},{"location":"api/symbolic/#Assumptions","page":"Symbolic Scalars","title":"Assumptions","text":"Available assumptions for Sym:\n\n:real - real number\n:positive - strictly positive (implies real)\n:negative - strictly negative (implies real)\n:nonnegative - non-negative (implies real)\n:integer - integer value\n:complex - complex number","category":"section"},{"location":"api/symbolic/#Evaluation-Functions","page":"Symbolic Scalars","title":"Evaluation Functions","text":"","category":"section"},{"location":"api/symbolic/#Substitution","page":"Symbolic Scalars","title":"Substitution","text":"","category":"section"},{"location":"api/symbolic/#Numeric-Evaluation","page":"Symbolic Scalars","title":"Numeric Evaluation","text":"","category":"section"},{"location":"api/symbolic/#Simplification","page":"Symbolic Scalars","title":"Simplification","text":"","category":"section"},{"location":"api/symbolic/#Introspection","page":"Symbolic Scalars","title":"Introspection","text":"","category":"section"},{"location":"api/symbolic/#KroneckerDelta-Behavior","page":"Symbolic Scalars","title":"KroneckerDelta Behavior","text":"# Concrete values\nKroneckerDelta(1, 1)  # â†’ 1\nKroneckerDelta(1, 2)  # â†’ 0\n\n# Literal Symbols\nKroneckerDelta(:a, :a) |> simplify  # â†’ 1\nKroneckerDelta(:a, :b) |> simplify  # â†’ 0\n\n# Symbolic variables (may be equal after substitution)\na, b = Sym(:a), Sym(:b)\nKroneckerDelta(a, b) |> simplify    # â†’ Î´(a,b) (stays symbolic)\nKroneckerDelta(a, a) |> simplify    # â†’ 1 (same variable)","category":"section"},{"location":"api/symbolic/#Examples","page":"Symbolic Scalars","title":"Examples","text":"using QSymbolic\n\n# Create symbolic variables\nn = Sym(:n, :nonnegative, :integer)\nÏ‰ = Sym(:Ï‰, :positive)\n\n# Build expressions\nE_n = Ï‰ * (n + 1//2)  # Harmonic oscillator energy\n\n# Substitute values\nE_0 = substitute(E_n, :n => 0)  # â†’ Ï‰/2\nE_numeric = substitute(E_0, :Ï‰ => 2Ï€) |> evaluate  # â†’ Ï€\n\n# Use in quantum states\nF, Fb = FockSpace(:mode)\nket_n = Ket(Fb, n)\nket_m = Ket(Fb, Sym(:m))\nket_m' * ket_n  # â†’ Î´(m,n)","category":"section"},{"location":"api/symbolic/#QSymbolic.Sym","page":"Symbolic Scalars","title":"QSymbolic.Sym","text":"Sym(name::Symbol)\nSym(name::Symbol; real=false, positive=false, negative=false, integer=false, nonnegative=false)\n\nCreate a symbolic variable with optional assumptions, using Symbolics.jl under the hood.\n\nSupported assumptions:\n\n:real / real=true - real number (conj(x) = x)\n:positive / positive=true - strictly positive real\n:negative / negative=true - strictly negative real  \n:nonnegative / nonnegative=true - non-negative real\n:integer / integer=true - integer value\n\nExamples\n\nn = Sym(:n)                     # generic symbolic\nm = Sym(:m, :real, :positive)   # real positive\nk = Sym(:k, integer=true)       # integer\n\n\n\n\n\n","category":"function"},{"location":"api/symbolic/#QSymbolic.KroneckerDelta","page":"Symbolic Scalars","title":"QSymbolic.KroneckerDelta","text":"KroneckerDelta(i, j)\n\nKronecker delta Î´áµ¢â±¼ = 1 if i == j, else 0. With Symbolics.jl, we use IfElse or direct evaluation when possible.\n\n\n\n\n\n","category":"type"},{"location":"api/symbolic/#QSymbolic.substitute","page":"Symbolic Scalars","title":"QSymbolic.substitute","text":"substitute(expr, pairs...)\nsubstitute(expr, dict)\n\nSubstitute values for symbolic variables.\n\n\n\n\n\n","category":"function"},{"location":"api/symbolic/#QSymbolic.evaluate","page":"Symbolic Scalars","title":"QSymbolic.evaluate","text":"evaluate(expr)\n\nEvaluate a symbolic expression to a numeric value. All symbolic variables must have been substituted with concrete values.\n\n\n\n\n\n","category":"function"},{"location":"api/symbolic/#QSymbolic.simplify","page":"Symbolic Scalars","title":"QSymbolic.simplify","text":"simplify(expr)\n\nSimplify a symbolic expression using Symbolics.jl's simplification engine.\n\n\n\n\n\n","category":"function"},{"location":"api/symbolic/#QSymbolic.symbols","page":"Symbolic Scalars","title":"QSymbolic.symbols","text":"Get all symbolic variables in an expression\n\n\n\n\n\n","category":"function"},{"location":"api/symbolic/#QSymbolic.is_numeric","page":"Symbolic Scalars","title":"QSymbolic.is_numeric","text":"Check if expression is purely numeric (can be evaluated)\n\n\n\n\n\n","category":"function"},{"location":"api/symbolic/#QSymbolic.is_real","page":"Symbolic Scalars","title":"QSymbolic.is_real","text":"Check if symbolic is assumed to be real\n\n\n\n\n\n","category":"function"},{"location":"api/symbolic/#QSymbolic.is_positive","page":"Symbolic Scalars","title":"QSymbolic.is_positive","text":"Check if symbolic is assumed to be positive\n\n\n\n\n\n","category":"function"},{"location":"api/symbolic/#QSymbolic.is_integer","page":"Symbolic Scalars","title":"QSymbolic.is_integer","text":"Check if symbolic is assumed to be an integer\n\n\n\n\n\n","category":"function"},{"location":"api/symbolic/#QSymbolic.assumptions","page":"Symbolic Scalars","title":"QSymbolic.assumptions","text":"Get assumptions of a symbolic variable (compatibility function)\n\n\n\n\n\n","category":"function"},{"location":"api/transforms/#Transforms","page":"Transforms","title":"Transforms","text":"Basis transformations allow you to express states in different representations. QSymbolic.jl maintains a registry of user-defined transforms and applies them automatically when computing cross-basis inner products.","category":"section"},{"location":"api/transforms/#Overview","page":"Transforms","title":"Overview","text":"The transform system works as follows:\n\nRegister transforms between bases using define_transform!\nQuery whether transforms exist with has_transform\nApply transforms explicitly with transform or let inner products use them automatically\n\nFor composite systems, transforms factorize automatically â€” if you define transforms for each subsystem, the composite transform is derived without additional registration.","category":"section"},{"location":"api/transforms/#Registering-Transforms","page":"Transforms","title":"Registering Transforms","text":"","category":"section"},{"location":"api/transforms/#Querying-Transforms","page":"Transforms","title":"Querying Transforms","text":"","category":"section"},{"location":"api/transforms/#Applying-Transforms","page":"Transforms","title":"Applying Transforms","text":"","category":"section"},{"location":"api/transforms/#Utilities","page":"Transforms","title":"Utilities","text":"","category":"section"},{"location":"api/transforms/#Examples","page":"Transforms","title":"Examples","text":"","category":"section"},{"location":"api/transforms/#Basic-Transform","page":"Transforms","title":"Basic Transform","text":"using QSymbolic\n\nH = HilbertSpace(:spin, 2)\nHb = Basis(H, :default)\nZb = Basis(H, :z)\nXb = Basis(H, :x)\n\nup_z = Ket(Zb, :â†‘)\ndown_z = Ket(Zb, :â†“)\n\n# Register X â†’ Z transform\ndefine_transform!(Xb, Zb) do idx\n    idx == :â†‘ ? (up_z + down_z)/âˆš2 : (up_z - down_z)/âˆš2\nend\n\n# Check availability\nhas_transform(typeof(Xb), typeof(Zb))  # true\n\n# Apply transform\nup_x = Ket(Xb, :â†‘)\ntransform(up_x, typeof(Zb))  # (|â†‘âŸ© + |â†“âŸ©)/âˆš2\n\n# Inner products now work automatically\nup_z' * up_x  # 1/âˆš2","category":"section"},{"location":"api/transforms/#Composite-Transform-(Factorized)","page":"Transforms","title":"Composite Transform (Factorized)","text":"H_A, H_B = HilbertSpace(:A, 2), HilbertSpace(:B, 2)\nZa, Xa = Basis(H_A, :z), Basis(H_A, :x)\nZb, Xb = Basis(H_B, :z), Basis(H_B, :x)\n\n# Define individual transforms (same pattern as above)\ndefine_transform!(Xa, Za) do idx\n    # ... x-to-z for subsystem A\nend\ndefine_transform!(Xb, Zb) do idx\n    # ... x-to-z for subsystem B  \nend\n\n# Composite transform is automatic!\nhas_transform(typeof(Xa âŠ— Xb), typeof(Za âŠ— Zb))  # true","category":"section"},{"location":"api/transforms/#QSymbolic.define_transform!","page":"Transforms","title":"QSymbolic.define_transform!","text":"define_transform!(f::Function, from::AbstractBasis, to::AbstractBasis)\n\nRegister a basis transformation. f(index) or f(ket) returns a ket in target basis.\n\nThe two bases must be on the same space. This works for:\n\nBasis to Basis (same space)\nCompositeBasis to CompositeBasis (same composite space)\nBasis on composite space to CompositeBasis (eigenbasis to product basis)\nCompositeBasis to Basis on composite space (product basis to eigenbasis)\n\nExample\n\nH = HilbertSpace(:spin, 2)\nZb, Xb = Basis(H, :z), Basis(H, :x)\nup_z, down_z = Ket(Zb, :â†‘), Ket(Zb, :â†“)\n\ndefine_transform!(Xb, Zb) do idx\n    idx == :â†‘ ? (up_z + down_z) / âˆš2 : (up_z - down_z) / âˆš2\nend\n\n# For composite systems, can transform between eigenbasis and product basis:\ncomposite = H1 âŠ— H2\neigenbasis = Basis(composite, :dressed)\nproduct_basis = B1 âŠ— B2\n\ndefine_transform!(eigenbasis, product_basis) do idx\n    # Return superposition in product basis\n    ...\nend\n\n\n\n\n\n","category":"function"},{"location":"api/transforms/#QSymbolic.has_transform","page":"Transforms","title":"QSymbolic.has_transform","text":"has_transform(B1, B2) -> Bool\n\nCheck if a transform from basis B1 to B2 exists (explicit or factorizable).\n\n\n\n\n\n","category":"function"},{"location":"api/transforms/#QSymbolic.transform","page":"Transforms","title":"QSymbolic.transform","text":"transform(ket, target_basis)\n\nTransform a ket from its current basis to the target basis. Works for:\n\nKet{B1} â†’ B2 (single-system bases, returns SumKet)\nProductKet{A1,A2} â†’ CompositeBasis{B1,B2} (factorized transforms)\nProductKet{A1,A2} â†’ Basis (composite to eigenbasis)\nSumKet, SumKet, WeightedKet (applies to each component)\n\n\n\n\n\n","category":"function"},{"location":"api/transforms/#QSymbolic.clear_transforms!","page":"Transforms","title":"QSymbolic.clear_transforms!","text":"clear_transforms!()\n\nClear all registered basis transforms.\n\n\n\n\n\n","category":"function"},{"location":"#QSymbolic.jl","page":"Home","title":"QSymbolic.jl","text":"A Julia package for symbolic quantum mechanics with basis-aware state representations.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Hilbert Spaces: Define finite and infinite-dimensional Hilbert spaces\nExplicit Bases: Named orthonormal bases with automatic orthogonality  \nFlexible Indices: Symbolic, numeric, or multi-index kets for composite systems\nBasis Transforms: Register transformations between bases; cross-basis inner products computed automatically\nComposite Systems: Tensor products with order-independent (bosonic) behavior and factorized transforms\nCustom Contraction Rules: Define non-orthonormal inner products for dressed states\nOperators: Outer product operators |ÏˆâŸ©âŸ¨Ï•|, operator algebra, and function-defined operators\nSymbolics.jl Backend: Full symbolic computation with Sym, @variables, KroneckerDelta","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/TendonFFF/QSymbolic.jl\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using QSymbolic\n\n# Create a 2-dimensional Hilbert space with default basis\nH, Hb = HilbertSpace(:spin, 2)\n\n# Define spin-z basis\nZb = Basis(H, :z)\n\n# Create kets in the z-basis\nup = Ket(Zb, :â†‘)\ndown = Ket(Zb, :â†“)\n\n# Orthonormality\nup' * up    # â†’ 1\nup' * down  # â†’ 0\n\n# Build operators via outer products\nP_up = up * up'      # |â†‘âŸ©âŸ¨â†‘| (projector)\nÏƒ_plus = up * down'  # |â†‘âŸ©âŸ¨â†“| (raising operator)\n\n# Apply operators\nP_up * up    # â†’ |â†‘âŸ©\nP_up * down  # â†’ 0\n\n# Pauli Z operator\nÏƒz = P_up - (down * down')\nÏƒz * up    # â†’ |â†‘âŸ©\nÏƒz * down  # â†’ -|â†“âŸ©\n\n# Symbolic variables (Symbolics.jl backend)\nn = Sym(:n, :nonnegative, :integer)\nâˆšn + 1  # â†’ 1 + âˆšn\n\n# Symbolic inner products\nF, Fb = FockSpace(:mode)\nket_n = Ket(Fb, n)\nm = Sym(:m, :nonnegative, :integer)\nKet(Fb, m)' * ket_n  # â†’ Î´(m,n) (KroneckerDelta)","category":"section"},{"location":"#Type-Hierarchy","page":"Home","title":"Type Hierarchy","text":"","category":"section"},{"location":"#States","page":"Home","title":"States","text":"AbstractKet\nâ”œâ”€â”€ Ket           # Basic ket with index: |ÏˆâŸ©\nâ”œâ”€â”€ ProductKet    # Tensor product: |ÏˆâŸ©âŠ—|Ï•âŸ© (order-independent)\nâ”œâ”€â”€ WeightedKet   # Scalar Ã— ket: Î±|ÏˆâŸ©\nâ””â”€â”€ SumKet        # Superposition: Î±|ÏˆâŸ© + Î²|Ï•âŸ©\n\nAbstractBra       # Lazy adjoints of kets\nâ”œâ”€â”€ Bra, ProductBra, WeightedBra, SumBra","category":"section"},{"location":"#Operators","page":"Home","title":"Operators","text":"AbstractOperator\nâ”œâ”€â”€ Outer            # Single |ÏˆâŸ©âŸ¨Ï•|\nâ”œâ”€â”€ Operator         # Sum of weighted outers\nâ”œâ”€â”€ Identity         # Identity ð•€\nâ””â”€â”€ FunctionOperator # User-defined action","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\n    \"guide/getting_started.md\",\n    \"guide/transforms.md\",\n    \"guide/composite.md\",\n    \"guide/operators.md\",\n    \"guide/symbolic.md\",\n    \"guide/contraction_rules.md\",\n    \"api/spaces.md\",\n    \"api/bases.md\",\n    \"api/states.md\",\n    \"api/transforms.md\",\n    \"api/operators.md\",\n    \"api/symbolic.md\",\n]\nDepth = 2","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"api/api/#Full-API","page":"Full API","title":"Full API","text":"This page provides a comprehensive list of all public and documented internal functions in QSymbolic.jl.\n\nFor topic-specific documentation, see the individual API pages:\n\nSpaces - Hilbert spaces and composite spaces\nBases - Basis types and operations\nStates - Kets, bras, and state operations\nTransforms - Basis transformations\nOperators - Quantum operators\nSymbolic Scalars - Symbolic computation\n\n","category":"section"},{"location":"api/api/#Additional-Operator-Types","page":"Full API","title":"Additional Operator Types","text":"These operator types are documented here for completeness:","category":"section"},{"location":"api/api/#Contraction-Rules-(Internal)","page":"Full API","title":"Contraction Rules (Internal)","text":"Functions for defining custom inner product behavior:","category":"section"},{"location":"api/api/#Basis-Utilities-(Internal)","page":"Full API","title":"Basis Utilities (Internal)","text":"","category":"section"},{"location":"api/api/#Symbolic-Utilities-(Internal)","page":"Full API","title":"Symbolic Utilities (Internal)","text":"","category":"section"},{"location":"api/api/#Iteration-Protocol","page":"Full API","title":"Iteration Protocol","text":"HilbertSpace supports iteration for convenient destructuring:","category":"section"},{"location":"api/api/#Tensor-Product-(Basis)","page":"Full API","title":"Tensor Product (Basis)","text":"","category":"section"},{"location":"api/api/#Multiplication","page":"Full API","title":"Multiplication","text":"Operator multiplication via bra-ket contraction:","category":"section"},{"location":"api/api/#Index","page":"Full API","title":"Index","text":"","category":"section"},{"location":"api/api/#QSymbolic.OperatorSum","page":"Full API","title":"QSymbolic.OperatorSum","text":"OperatorSum{S<:AbstractSpace}\n\nLazy container for sum of operators. Preserves different operator types (Identity, Operator, FunctionOperator, etc.) without forcing evaluation.\n\nEnables expressions like:\n\nOp + cÂ·ð•€ (operator plus scaled identity)\nOpâ‚ + Opâ‚‚ + FuncOp (mixing operator types)\n\nApplication evaluates lazily: (A + B)|ÏˆâŸ© = A|ÏˆâŸ© + B|ÏˆâŸ©\n\nExamples\n\nH, Hb = HilbertSpace(:H, 2)\nÏƒ_z = Ket(Hb, :â†‘) * Ket(Hb, :â†‘)' - Ket(Hb, :â†“) * Ket(Hb, :â†“)'\nH_shifted = Ïƒ_z + 2 * Identity(H)  # Ïƒ_z + 2ð•€\n\n# Application\nÏˆ = Ket(Hb, :â†‘)\nH_shifted * Ïˆ  # â†’ Ïƒ_z|â†‘âŸ© + 2|â†‘âŸ© = 3|â†‘âŸ©\n\nSee also: Operator, Identity, Outer\n\n\n\n\n\n","category":"type"},{"location":"api/api/#QSymbolic.OperatorProduct","page":"Full API","title":"QSymbolic.OperatorProduct","text":"OperatorProduct\n\nLazy container for product of operators. Operators may be from different spaces, enabling cross-space operator expressions. Validity is checked when applied to a ket.\n\nEnables expressions like:\n\nA * B where A and B are on different spaces (tensor product context)\n(a + aâ€ ) * (|eâŸ©âŸ¨g| + |gâŸ©âŸ¨e|) mixing cavity and dot spaces\n\nApplication evaluates right-to-left: (ABC)|ÏˆâŸ© = A(B(C|ÏˆâŸ©))\n\nExamples\n\n# Cross-space lazy product\ncavity_op = a + a'   # annihilation + creation on cavity\ndot_op = eg + ge     # |eâŸ©âŸ¨g| + |gâŸ©âŸ¨e| on dot\n\nH_int = cavity_op * dot_op  # Creates OperatorProduct (no space check)\n\n# Valid when applied to composite ket:\nÏˆ = |nâŸ© âŠ— |gâŸ©\nH_int * Ïˆ  # Evaluated at application time\n\nSee also: OperatorSum, Operator\n\n\n\n\n\n","category":"type"},{"location":"api/api/#QSymbolic.tr","page":"Full API","title":"QSymbolic.tr","text":"tr(op::AbstractOperator)\n\nCompute the trace of an operator.\n\nFor an outer product |ÏˆâŸ©âŸ¨Ï•|, the trace is âŸ¨Ï•|ÏˆâŸ©. For a sum of weighted outers Î£áµ¢ wáµ¢|Ïˆáµ¢âŸ©âŸ¨Ï•áµ¢|, the trace is Î£áµ¢ wáµ¢âŸ¨Ï•áµ¢|Ïˆáµ¢âŸ©.\n\nExamples\n\nH, Hb = HilbertSpace(:H, 2)\nup = Ket(Hb, :â†‘)\ndown = Ket(Hb, :â†“)\n\n# Projector - trace is 1\nP_up = up * up'\ntr(P_up)  # â†’ 1\n\n# Off-diagonal - trace is 0 (orthonormal basis)\nÏƒ_plus = up * down'\ntr(Ïƒ_plus)  # â†’ 0\n\n# Ïƒ_x = |â†‘âŸ©âŸ¨â†“| + |â†“âŸ©âŸ¨â†‘| - trace is 0\nÏƒ_x = up * down' + down * up'\ntr(Ïƒ_x)  # â†’ 0\n\nSee also: Outer, Operator\n\n\n\n\n\n","category":"function"},{"location":"api/api/#QSymbolic.define_contraction_rule!","page":"Full API","title":"QSymbolic.define_contraction_rule!","text":"define_contraction_rule!(basis::Type{<:AbstractBasis}, rule::Function)\ndefine_contraction_rule!(basis_type, rule) do bra_idx, ket_idx\n    # Custom contraction logic\n    return result\nend\n\nDefine a custom contraction rule for computing inner products in a specific basis.\n\nThe rule function should take two arguments:\n\nbra_idx: The index of the bra (can be single value or tuple)\nket_idx: The index of the ket (can be single value or tuple)\n\nAnd return:\n\nA number (scalar result)\nA symbolic expression (e.g., KroneckerDelta)\nA Dirac delta expression\n\nExamples\n\n# Define a contraction rule for Fock basis that returns overlap integrals\nF = FockSpace(:F)\nFb = Basis(F, :n)\n\ndefine_contraction_rule!(typeof(Fb)) do i, j\n    # For Fock states, orthonormal: âŸ¨i|jâŸ© = Î´áµ¢â±¼\n    if i isa AbstractSymbolic || j isa AbstractSymbolic\n        return isequal(i, j) ? 1 : KroneckerDelta(i, j)\n    else\n        return i == j ? 1 : 0\n    end\nend\n\n# Define a non-orthonormal basis with overlap\nH = HilbertSpace(:H, 2)\nCb = Basis(H, :coherent)\n\n@syms Î± Î²\ndefine_contraction_rule!(typeof(Cb)) do i, j\n    # Coherent states: âŸ¨Î±|Î²âŸ© = exp(-|Î±-Î²|Â²/2)\n    if i isa AbstractSymbolic && j isa AbstractSymbolic\n        # Return symbolic expression\n        exp(-abs(i - j)^2 / 2)\n    else\n        # Evaluate numerically\n        exp(-abs(i - j)^2 / 2)\n    end\nend\n\nSee also: has_contraction_rule, clear_contraction_rules!\n\n\n\n\n\n","category":"function"},{"location":"api/api/#QSymbolic.has_contraction_rule","page":"Full API","title":"QSymbolic.has_contraction_rule","text":"has_contraction_rule(basis::Type{<:AbstractBasis}) -> Bool\n\nCheck if a custom contraction rule has been defined for the given basis.\n\nExamples\n\nH = HilbertSpace(:H, 2)\nZb = Basis(H, :z)\n\nhas_contraction_rule(typeof(Zb))  # false (uses default)\n\ndefine_contraction_rule!(typeof(Zb)) do i, j\n    i == j ? 1 : 0\nend\n\nhas_contraction_rule(typeof(Zb))  # true\n\nSee also: define_contraction_rule!\n\n\n\n\n\n","category":"function"},{"location":"api/api/#QSymbolic.get_contraction_rule","page":"Full API","title":"QSymbolic.get_contraction_rule","text":"get_contraction_rule(basis::Type{<:AbstractBasis}) -> Function\n\nGet the custom contraction rule for a basis, or return nothing if not defined.\n\nSee also: define_contraction_rule!, has_contraction_rule\n\n\n\n\n\n","category":"function"},{"location":"api/api/#QSymbolic.apply_contraction_rule","page":"Full API","title":"QSymbolic.apply_contraction_rule","text":"apply_contraction_rule(basis::Type{<:AbstractBasis}, bra_idx, ket_idx)\n\nApply the contraction rule for a basis (custom if defined, otherwise default).\n\nThe default rule checks if indices are equal:\n\nIf both concrete: return 1 if equal, 0 if not\nIf any symbolic: return 1 if symbolically equal, KroneckerDelta otherwise\nFor tuples: check component-wise\n\nExamples\n\nH = HilbertSpace(:H, 2)\nZb = Basis(H, :z)\n\n# Default rule (orthonormal)\napply_contraction_rule(typeof(Zb), :â†‘, :â†‘)  # 1\napply_contraction_rule(typeof(Zb), :â†‘, :â†“)  # 0\n\n# With symbolic\nn = Sym(:n)\napply_contraction_rule(typeof(Zb), n, n)  # 1\napply_contraction_rule(typeof(Zb), n, :â†‘)  # KroneckerDelta(n, :â†‘)\n\nSee also: define_contraction_rule!\n\n\n\n\n\n","category":"function"},{"location":"api/api/#QSymbolic.clear_contraction_rules!","page":"Full API","title":"QSymbolic.clear_contraction_rules!","text":"clear_contraction_rules!()\n\nClear all custom contraction rules, reverting to default index-based checking.\n\nSee also: define_contraction_rule!\n\n\n\n\n\n","category":"function"},{"location":"api/api/#QSymbolic.bases","page":"Full API","title":"QSymbolic.bases","text":"bases(cb::CompositeBasis)\n\nGet all component bases of a composite basis as a tuple.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#QSymbolic.get_transform","page":"Full API","title":"QSymbolic.get_transform","text":"get_transform(B1, B2) -> Function\n\nGet the registered transform function from B1 to B2.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#QSymbolic.SymNum","page":"Full API","title":"QSymbolic.SymNum","text":"SymNum(value)\n\nWraps a numeric value. With Symbolics.jl integration, this just returns  the value directly since Symbolics handles numeric constants natively.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#QSymbolic.SymExpr","page":"Full API","title":"QSymbolic.SymExpr","text":"SymExpr(op, args...)\n\nCreate a symbolic expression. With Symbolics.jl, expressions are built automatically through arithmetic operations.\n\nThis constructor is provided for compatibility but you should prefer using natural arithmetic syntax.\n\n\n\n\n\n","category":"function"},{"location":"api/api/#QSymbolic.AbstractSymbolic","page":"Full API","title":"QSymbolic.AbstractSymbolic","text":"AbstractSymbolic\n\nAbstract supertype for all symbolic scalar types. This is now an alias that accepts both our wrappers and Symbolics.jl types.\n\n\n\n\n\n","category":"type"},{"location":"api/api/#QSymbolic.is_nonnegative","page":"Full API","title":"QSymbolic.is_nonnegative","text":"Check if symbolic is assumed to be non-negative\n\n\n\n\n\n","category":"function"},{"location":"api/api/#Base.iterate-Tuple{HilbertSpace}","page":"Full API","title":"Base.iterate","text":"iterate(space::HilbertSpace)\niterate(space::HilbertSpace, state)\n\nIteration protocol for HilbertSpace that enables convenient destructuring.\n\nExamples\n\njulia> H = HilbertSpace(:H, 2)  # Just the space\nâ„‹(H, dim=2)\n\njulia> H, Hb = HilbertSpace(:H, 2);  # Space and default basis\n\njulia> H\nâ„‹(H, dim=2)\n\njulia> Hb\nBasis{default}\n\nThe first iteration returns the space itself, and the second returns a default basis. This allows for convenient syntax where you can get both the space and a default basis in one line.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#QSymbolic.:âŠ—-Union{Tuple{B2}, Tuple{B1}, Tuple{B1, B2}} where {B1<:AbstractBasis, B2<:AbstractBasis}","page":"Full API","title":"QSymbolic.:âŠ—","text":"âŠ—(basis1::AbstractBasis, basis2::AbstractBasis)\nâŠ—(cb::CompositeBasis, basis::AbstractBasis)\nâŠ—(basis::AbstractBasis, cb::CompositeBasis)\n\nTensor product of bases. Supports chaining for multiple bases.\n\n\n\n\n\n","category":"method"},{"location":"api/api/#Base.:*-Union{Tuple{S}, Tuple{Outer{S}, Outer{S}}} where S","page":"Full API","title":"Base.:*","text":"Operator multiplication using bra-ket contraction.\n\nFor A = Î£áµ¢ wáµ¢|aáµ¢âŸ©âŸ¨báµ¢| and B = Î£â±¼ vâ±¼|câ±¼âŸ©âŸ¨dâ±¼|:     A * B = Î£áµ¢â±¼ wáµ¢vâ±¼âŸ¨báµ¢|câ±¼âŸ© |aáµ¢âŸ©âŸ¨dâ±¼|\n\nThe contraction âŸ¨báµ¢|câ±¼âŸ© uses bra-ket arithmetic, which handles:\n\nSame basis, same index: 1\nSame basis, different index: 0\nCross-basis: InnerProduct or custom transform\n\n\n\n\n\n","category":"method"},{"location":"guide/transforms/#Basis-Transforms","page":"Basis Transforms","title":"Basis Transforms","text":"QSymbolic.jl supports explicit bases and user-defined transformations between them. This is essential for quantum mechanics, where the same physical state can be expressed in different representations.","category":"section"},{"location":"guide/transforms/#Why-Explicit-Bases?","page":"Basis Transforms","title":"Why Explicit Bases?","text":"In quantum mechanics, choosing a basis is like choosing a coordinate system. The same state looks different in different bases. For example, a spin-1/2 particle's \"spin-up\" state in the z-basis is a superposition in the x-basis:\n\n_z = frac1sqrt2(_x + _x)\n\nQSymbolic.jl makes bases explicit, so you can:\n\nTrack which basis states live in\nDefine transforms between bases\nAutomatically compute cross-basis inner products","category":"section"},{"location":"guide/transforms/#Creating-Bases","page":"Basis Transforms","title":"Creating Bases","text":"Use Basis(space, name) to create a named orthonormal basis:\n\nusing QSymbolic\n\nH = HilbertSpace(:spin, 2)\n\n# Define different bases for the same space\nZb = Basis(H, :z)  # spin-z eigenbasis\nXb = Basis(H, :x)  # spin-x eigenbasis\n\n# Create states in specific bases\nup_z = Ket(Zb, :â†‘)\ndown_z = Ket(Zb, :â†“)\nup_x = Ket(Xb, :â†‘)\ndown_x = Ket(Xb, :â†“)\n\ntip: Convenient Destructuring\nUse H, Hb = HilbertSpace(:H, 2) to get both space and a default basis in one line.","category":"section"},{"location":"guide/transforms/#Orthonormality-Within-a-Basis","page":"Basis Transforms","title":"Orthonormality Within a Basis","text":"States in the same basis are automatically orthonormal:\n\nup_z' * up_z    # â†’ 1 (normalized)\nup_z' * down_z  # â†’ 0 (orthogonal)\n\nup_x' * up_x    # â†’ 1\nup_x' * down_x  # â†’ 0","category":"section"},{"location":"guide/transforms/#Cross-Basis-Inner-Products","page":"Basis Transforms","title":"Cross-Basis Inner Products","text":"Without knowing the relationship between bases, cross-basis inner products return a symbolic result:\n\nup_z' * up_x  # â†’ InnerProduct (symbolic, unevaluated)","category":"section"},{"location":"guide/transforms/#Registering-Transforms","page":"Basis Transforms","title":"Registering Transforms","text":"Tell QSymbolic how to transform between bases using define_transform!:\n\n# Define transform from x-basis to z-basis\ndefine_transform!(Xb, Zb) do idx\n    if idx == :â†‘\n        (up_z + down_z) / âˆš2    # |â†‘_xâŸ© = (|â†‘_zâŸ© + |â†“_zâŸ©)/âˆš2\n    else\n        (up_z - down_z) / âˆš2    # |â†“_xâŸ© = (|â†‘_zâŸ© - |â†“_zâŸ©)/âˆš2\n    end\nend\n\nNow cross-basis inner products are computed automatically:\n\nup_z' * up_x    # â†’ 1/âˆš2 â‰ˆ 0.7071\ndown_z' * up_x  # â†’ 1/âˆš2 â‰ˆ 0.7071\nup_z' * down_x  # â†’ 1/âˆš2 â‰ˆ 0.7071\ndown_z' * down_x # â†’ -1/âˆš2 â‰ˆ -0.7071","category":"section"},{"location":"guide/transforms/#Transform-API","page":"Basis Transforms","title":"Transform API","text":"","category":"section"},{"location":"guide/transforms/#Check-if-a-Transform-Exists","page":"Basis Transforms","title":"Check if a Transform Exists","text":"has_transform(typeof(Xb), typeof(Zb))  # â†’ true\nhas_transform(typeof(Zb), typeof(Xb))  # â†’ false (not defined yet)","category":"section"},{"location":"guide/transforms/#Apply-Transform-Explicitly","page":"Basis Transforms","title":"Apply Transform Explicitly","text":"transform(up_x, typeof(Zb))  # â†’ (|â†‘âŸ© + |â†“âŸ©)/âˆš2 as SumKet","category":"section"},{"location":"guide/transforms/#Clear-All-Transforms","page":"Basis Transforms","title":"Clear All Transforms","text":"clear_transforms!()  # Remove all registered transforms","category":"section"},{"location":"guide/transforms/#Bidirectional-Transforms","page":"Basis Transforms","title":"Bidirectional Transforms","text":"Transforms are directional. Register both directions if needed:\n\n# X â†’ Z (spin-x to spin-z)\ndefine_transform!(Xb, Zb) do idx\n    idx == :â†‘ ? (up_z + down_z)/âˆš2 : (up_z - down_z)/âˆš2\nend\n\n# Z â†’ X (spin-z to spin-x)  \ndefine_transform!(Zb, Xb) do idx\n    idx == :â†‘ ? (up_x + down_x)/âˆš2 : (up_x - down_x)/âˆš2\nend","category":"section"},{"location":"guide/transforms/#Factorized-Transforms-(Composite-Systems)","page":"Basis Transforms","title":"Factorized Transforms (Composite Systems)","text":"For composite systems, transforms factorize automatically. See Composite Systems for details.\n\nH_A, H_B = HilbertSpace(:A, 2), HilbertSpace(:B, 2)\nZa, Xa = Basis(H_A, :z), Basis(H_A, :x)\nZb, Xb = Basis(H_B, :z), Basis(H_B, :x)\n\n# Define individual transforms\ndefine_transform!(Xa, Za) do idx ... end\ndefine_transform!(Xb, Zb) do idx ... end\n\n# Composite transform XaâŠ—Xb â†’ ZaâŠ—Zb works automatically!\nhas_transform(typeof(Xa âŠ— Xb), typeof(Za âŠ— Zb))  # â†’ true","category":"section"},{"location":"guide/transforms/#Complete-Example","page":"Basis Transforms","title":"Complete Example","text":"using QSymbolic\n\nH = HilbertSpace(:spin, 2)\nZb = Basis(H, :z)\nXb = Basis(H, :x)\n\n# Z-basis states\nup_z = Ket(Zb, :â†‘)\ndown_z = Ket(Zb, :â†“)\n\n# X-basis states  \nup_x = Ket(Xb, :â†‘)\ndown_x = Ket(Xb, :â†“)\n\n# Define X â†’ Z transform\ndefine_transform!(Xb, Zb) do idx\n    idx == :â†‘ ? (up_z + down_z)/âˆš2 : (up_z - down_z)/âˆš2\nend\n\n# Now cross-basis inner products work\nup_z' * up_x    # â†’ 0.7071...\n\n# Explicit transform\ntransform(up_x, typeof(Zb))  # â†’ SumKet: 0.7071|â†‘âŸ© + 0.7071|â†“âŸ©","category":"section"},{"location":"guide/transforms/#See-Also","page":"Basis Transforms","title":"See Also","text":"Getting Started - Basic ket/bra operations\nComposite Systems - Tensor products with factorized transforms","category":"section"}]
}
