<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Full API ¬∑ QSymbolic.jl</title><meta name="title" content="Full API ¬∑ QSymbolic.jl"/><meta property="og:title" content="Full API ¬∑ QSymbolic.jl"/><meta property="twitter:title" content="Full API ¬∑ QSymbolic.jl"/><meta name="description" content="Documentation for QSymbolic.jl."/><meta property="og:description" content="Documentation for QSymbolic.jl."/><meta property="twitter:description" content="Documentation for QSymbolic.jl."/><meta property="og:url" content="https://TendonFFF.github.io/QSymbolic.jl/api/api/"/><meta property="twitter:url" content="https://TendonFFF.github.io/QSymbolic.jl/api/api/"/><link rel="canonical" href="https://TendonFFF.github.io/QSymbolic.jl/api/api/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QSymbolic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../../guide/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../guide/transforms/">Basis Transforms</a></li><li><a class="tocitem" href="../../guide/composite/">Composite Systems</a></li><li><a class="tocitem" href="../../guide/operators/">Operators</a></li><li><a class="tocitem" href="../../guide/symbolic/">Symbolic Scalars</a></li><li><a class="tocitem" href="../../guide/contraction_rules/">Custom Contraction Rules</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>Full API</a><ul class="internal"><li><a class="tocitem" href="#Additional-Operator-Types"><span>Additional Operator Types</span></a></li><li><a class="tocitem" href="#Contraction-Rules-(Internal)"><span>Contraction Rules (Internal)</span></a></li><li><a class="tocitem" href="#Basis-Utilities-(Internal)"><span>Basis Utilities (Internal)</span></a></li><li><a class="tocitem" href="#Symbolic-Utilities-(Internal)"><span>Symbolic Utilities (Internal)</span></a></li><li><a class="tocitem" href="#Iteration-Protocol"><span>Iteration Protocol</span></a></li><li><a class="tocitem" href="#Tensor-Product-(Basis)"><span>Tensor Product (Basis)</span></a></li><li><a class="tocitem" href="#Multiplication"><span>Multiplication</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../spaces/">Spaces</a></li><li><a class="tocitem" href="../bases/">Bases</a></li><li><a class="tocitem" href="../states/">States</a></li><li><a class="tocitem" href="../transforms/">Transforms</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../symbolic/">Symbolic Scalars</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Full API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Full API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TendonFFF/QSymbolic.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/TendonFFF/QSymbolic.jl/blob/main/docs/src/api/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-API"><a class="docs-heading-anchor" href="#Full-API">Full API</a><a id="Full-API-1"></a><a class="docs-heading-anchor-permalink" href="#Full-API" title="Permalink"></a></h1><p>This page provides a comprehensive list of all public and documented internal functions in QSymbolic.jl.</p><p>For topic-specific documentation, see the individual API pages:</p><ul><li><a href="../spaces/">Spaces</a> - Hilbert spaces and composite spaces</li><li><a href="../bases/">Bases</a> - Basis types and operations</li><li><a href="../states/">States</a> - Kets, bras, and state operations</li><li><a href="../transforms/">Transforms</a> - Basis transformations</li><li><a href="../operators/">Operators</a> - Quantum operators</li><li><a href="../symbolic/">Symbolic Scalars</a> - Symbolic computation</li></ul><hr/><h2 id="Additional-Operator-Types"><a class="docs-heading-anchor" href="#Additional-Operator-Types">Additional Operator Types</a><a id="Additional-Operator-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Operator-Types" title="Permalink"></a></h2><p>These operator types are documented here for completeness:</p><article><details class="docstring" open="true"><summary id="QSymbolic.OperatorSum"><a class="docstring-binding" href="#QSymbolic.OperatorSum"><code>QSymbolic.OperatorSum</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OperatorSum{S&lt;:AbstractSpace}</code></pre><p>Lazy container for sum of operators. Preserves different operator types (Identity, Operator, FunctionOperator, etc.) without forcing evaluation.</p><p>Enables expressions like:</p><ul><li>Op + c¬∑ùïÄ (operator plus scaled identity)</li><li>Op‚ÇÅ + Op‚ÇÇ + FuncOp (mixing operator types)</li></ul><p>Application evaluates lazily: (A + B)|œà‚ü© = A|œà‚ü© + B|œà‚ü©</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">H, Hb = HilbertSpace(:H, 2)
œÉ_z = Ket(Hb, :‚Üë) * Ket(Hb, :‚Üë)&#39; - Ket(Hb, :‚Üì) * Ket(Hb, :‚Üì)&#39;
H_shifted = œÉ_z + 2 * Identity(H)  # œÉ_z + 2ùïÄ

# Application
œà = Ket(Hb, :‚Üë)
H_shifted * œà  # ‚Üí œÉ_z|‚Üë‚ü© + 2|‚Üë‚ü© = 3|‚Üë‚ü©</code></pre><p>See also: <a href="../operators/#QSymbolic.Operator"><code>Operator</code></a>, <a href="../operators/#QSymbolic.Identity"><code>Identity</code></a>, <a href="../operators/#QSymbolic.Outer"><code>Outer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/types/operators.jl#L255-L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QSymbolic.OperatorProduct"><a class="docstring-binding" href="#QSymbolic.OperatorProduct"><code>QSymbolic.OperatorProduct</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OperatorProduct</code></pre><p>Lazy container for product of operators. Operators may be from different spaces, enabling cross-space operator expressions. Validity is checked when applied to a ket.</p><p>Enables expressions like:</p><ul><li>A * B where A and B are on different spaces (tensor product context)</li><li>(a + a‚Ä†) * (|e‚ü©‚ü®g| + |g‚ü©‚ü®e|) mixing cavity and dot spaces</li></ul><p>Application evaluates right-to-left: (ABC)|œà‚ü© = A(B(C|œà‚ü©))</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Cross-space lazy product
cavity_op = a + a&#39;   # annihilation + creation on cavity
dot_op = eg + ge     # |e‚ü©‚ü®g| + |g‚ü©‚ü®e| on dot

H_int = cavity_op * dot_op  # Creates OperatorProduct (no space check)

# Valid when applied to composite ket:
œà = |n‚ü© ‚äó |g‚ü©
H_int * œà  # Evaluated at application time</code></pre><p>See also: <a href="#QSymbolic.OperatorSum"><code>OperatorSum</code></a>, <a href="../operators/#QSymbolic.Operator"><code>Operator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/types/operators.jl#L308-L334">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QSymbolic.tr"><a class="docstring-binding" href="#QSymbolic.tr"><code>QSymbolic.tr</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tr(op::AbstractOperator)</code></pre><p>Compute the trace of an operator.</p><p>For an outer product |œà‚ü©‚ü®œï|, the trace is ‚ü®œï|œà‚ü©. For a sum of weighted outers Œ£·µ¢ w·µ¢|œà·µ¢‚ü©‚ü®œï·µ¢|, the trace is Œ£·µ¢ w·µ¢‚ü®œï·µ¢|œà·µ¢‚ü©.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">H, Hb = HilbertSpace(:H, 2)
up = Ket(Hb, :‚Üë)
down = Ket(Hb, :‚Üì)

# Projector - trace is 1
P_up = up * up&#39;
tr(P_up)  # ‚Üí 1

# Off-diagonal - trace is 0 (orthonormal basis)
œÉ_plus = up * down&#39;
tr(œÉ_plus)  # ‚Üí 0

# œÉ_x = |‚Üë‚ü©‚ü®‚Üì| + |‚Üì‚ü©‚ü®‚Üë| - trace is 0
œÉ_x = up * down&#39; + down * up&#39;
tr(œÉ_x)  # ‚Üí 0</code></pre><p>See also: <a href="../operators/#QSymbolic.Outer"><code>Outer</code></a>, <a href="../operators/#QSymbolic.Operator"><code>Operator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/types/operators.jl#L363-L391">source</a></section></details></article><h2 id="Contraction-Rules-(Internal)"><a class="docs-heading-anchor" href="#Contraction-Rules-(Internal)">Contraction Rules (Internal)</a><a id="Contraction-Rules-(Internal)-1"></a><a class="docs-heading-anchor-permalink" href="#Contraction-Rules-(Internal)" title="Permalink"></a></h2><p>Functions for defining custom inner product behavior:</p><article><details class="docstring" open="true"><summary id="QSymbolic.define_contraction_rule!"><a class="docstring-binding" href="#QSymbolic.define_contraction_rule!"><code>QSymbolic.define_contraction_rule!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">define_contraction_rule!(basis::Type{&lt;:AbstractBasis}, rule::Function)
define_contraction_rule!(basis_type, rule) do bra_idx, ket_idx
    # Custom contraction logic
    return result
end</code></pre><p>Define a custom contraction rule for computing inner products in a specific basis.</p><p>The rule function should take two arguments:</p><ul><li><code>bra_idx</code>: The index of the bra (can be single value or tuple)</li><li><code>ket_idx</code>: The index of the ket (can be single value or tuple)</li></ul><p>And return:</p><ul><li>A number (scalar result)</li><li>A symbolic expression (e.g., KroneckerDelta)</li><li>A Dirac delta expression</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Define a contraction rule for Fock basis that returns overlap integrals
F = FockSpace(:F)
Fb = Basis(F, :n)

define_contraction_rule!(typeof(Fb)) do i, j
    # For Fock states, orthonormal: ‚ü®i|j‚ü© = Œ¥·µ¢‚±º
    if i isa AbstractSymbolic || j isa AbstractSymbolic
        return isequal(i, j) ? 1 : KroneckerDelta(i, j)
    else
        return i == j ? 1 : 0
    end
end

# Define a non-orthonormal basis with overlap
H = HilbertSpace(:H, 2)
Cb = Basis(H, :coherent)

@syms Œ± Œ≤
define_contraction_rule!(typeof(Cb)) do i, j
    # Coherent states: ‚ü®Œ±|Œ≤‚ü© = exp(-|Œ±-Œ≤|¬≤/2)
    if i isa AbstractSymbolic &amp;&amp; j isa AbstractSymbolic
        # Return symbolic expression
        exp(-abs(i - j)^2 / 2)
    else
        # Evaluate numerically
        exp(-abs(i - j)^2 / 2)
    end
end</code></pre><p>See also: <a href="#QSymbolic.has_contraction_rule"><code>has_contraction_rule</code></a>, <a href="#QSymbolic.clear_contraction_rules!"><code>clear_contraction_rules!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/contraction_rules.jl#L13-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QSymbolic.has_contraction_rule"><a class="docstring-binding" href="#QSymbolic.has_contraction_rule"><code>QSymbolic.has_contraction_rule</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_contraction_rule(basis::Type{&lt;:AbstractBasis}) -&gt; Bool</code></pre><p>Check if a custom contraction rule has been defined for the given basis.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">H = HilbertSpace(:H, 2)
Zb = Basis(H, :z)

has_contraction_rule(typeof(Zb))  # false (uses default)

define_contraction_rule!(typeof(Zb)) do i, j
    i == j ? 1 : 0
end

has_contraction_rule(typeof(Zb))  # true</code></pre><p>See also: <a href="#QSymbolic.define_contraction_rule!"><code>define_contraction_rule!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/contraction_rules.jl#L75-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QSymbolic.get_contraction_rule"><a class="docstring-binding" href="#QSymbolic.get_contraction_rule"><code>QSymbolic.get_contraction_rule</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_contraction_rule(basis::Type{&lt;:AbstractBasis}) -&gt; Function</code></pre><p>Get the custom contraction rule for a basis, or return nothing if not defined.</p><p>See also: <a href="#QSymbolic.define_contraction_rule!"><code>define_contraction_rule!</code></a>, <a href="#QSymbolic.has_contraction_rule"><code>has_contraction_rule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/contraction_rules.jl#L100-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QSymbolic.apply_contraction_rule"><a class="docstring-binding" href="#QSymbolic.apply_contraction_rule"><code>QSymbolic.apply_contraction_rule</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply_contraction_rule(basis::Type{&lt;:AbstractBasis}, bra_idx, ket_idx)</code></pre><p>Apply the contraction rule for a basis (custom if defined, otherwise default).</p><p>The default rule checks if indices are equal:</p><ul><li>If both concrete: return 1 if equal, 0 if not</li><li>If any symbolic: return 1 if symbolically equal, KroneckerDelta otherwise</li><li>For tuples: check component-wise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">H = HilbertSpace(:H, 2)
Zb = Basis(H, :z)

# Default rule (orthonormal)
apply_contraction_rule(typeof(Zb), :‚Üë, :‚Üë)  # 1
apply_contraction_rule(typeof(Zb), :‚Üë, :‚Üì)  # 0

# With symbolic
n = Sym(:n)
apply_contraction_rule(typeof(Zb), n, n)  # 1
apply_contraction_rule(typeof(Zb), n, :‚Üë)  # KroneckerDelta(n, :‚Üë)</code></pre><p>See also: <a href="#QSymbolic.define_contraction_rule!"><code>define_contraction_rule!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/contraction_rules.jl#L123-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QSymbolic.clear_contraction_rules!"><a class="docstring-binding" href="#QSymbolic.clear_contraction_rules!"><code>QSymbolic.clear_contraction_rules!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clear_contraction_rules!()</code></pre><p>Clear all custom contraction rules, reverting to default index-based checking.</p><p>See also: <a href="#QSymbolic.define_contraction_rule!"><code>define_contraction_rule!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/contraction_rules.jl#L111-L117">source</a></section></details></article><h2 id="Basis-Utilities-(Internal)"><a class="docs-heading-anchor" href="#Basis-Utilities-(Internal)">Basis Utilities (Internal)</a><a id="Basis-Utilities-(Internal)-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-Utilities-(Internal)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QSymbolic.bases"><a class="docstring-binding" href="#QSymbolic.bases"><code>QSymbolic.bases</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">bases(cb::CompositeBasis)</code></pre><p>Get all component bases of a composite basis as a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/basis.jl#L150-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QSymbolic.get_transform"><a class="docstring-binding" href="#QSymbolic.get_transform"><code>QSymbolic.get_transform</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_transform(B1, B2) -&gt; Function</code></pre><p>Get the registered transform function from B1 to B2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/basis_transforms.jl#L72-L76">source</a></section></details></article><h2 id="Symbolic-Utilities-(Internal)"><a class="docs-heading-anchor" href="#Symbolic-Utilities-(Internal)">Symbolic Utilities (Internal)</a><a id="Symbolic-Utilities-(Internal)-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Utilities-(Internal)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QSymbolic.SymNum"><a class="docstring-binding" href="#QSymbolic.SymNum"><code>QSymbolic.SymNum</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SymNum(value)</code></pre><p>Wraps a numeric value. With Symbolics.jl integration, this just returns  the value directly since Symbolics handles numeric constants natively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/symbolic_scalar_symbolics.jl#L91-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QSymbolic.SymExpr"><a class="docstring-binding" href="#QSymbolic.SymExpr"><code>QSymbolic.SymExpr</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SymExpr(op, args...)</code></pre><p>Create a symbolic expression. With Symbolics.jl, expressions are built automatically through arithmetic operations.</p><p>This constructor is provided for compatibility but you should prefer using natural arithmetic syntax.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/symbolic_scalar_symbolics.jl#L102-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QSymbolic.AbstractSymbolic"><a class="docstring-binding" href="#QSymbolic.AbstractSymbolic"><code>QSymbolic.AbstractSymbolic</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSymbolic</code></pre><p>Abstract supertype for all symbolic scalar types. This is now an alias that accepts both our wrappers and Symbolics.jl types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/symbolic_scalar_symbolics.jl#L14-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QSymbolic.is_nonnegative"><a class="docstring-binding" href="#QSymbolic.is_nonnegative"><code>QSymbolic.is_nonnegative</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Check if symbolic is assumed to be non-negative</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/symbolic_scalar_symbolics.jl#L461">source</a></section></details></article><h2 id="Iteration-Protocol"><a class="docs-heading-anchor" href="#Iteration-Protocol">Iteration Protocol</a><a id="Iteration-Protocol-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration-Protocol" title="Permalink"></a></h2><p><code>HilbertSpace</code> supports iteration for convenient destructuring:</p><article><details class="docstring" open="true"><summary id="Base.iterate-Tuple{HilbertSpace}"><a class="docstring-binding" href="#Base.iterate-Tuple{HilbertSpace}"><code>Base.iterate</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iterate(space::HilbertSpace)
iterate(space::HilbertSpace, state)</code></pre><p>Iteration protocol for <code>HilbertSpace</code> that enables convenient destructuring.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H = HilbertSpace(:H, 2)  # Just the space
‚Ñã(H, dim=2)

julia&gt; H, Hb = HilbertSpace(:H, 2);  # Space and default basis

julia&gt; H
‚Ñã(H, dim=2)

julia&gt; Hb
Basis{default}</code></pre><p>The first iteration returns the space itself, and the second returns a default basis. This allows for convenient syntax where you can get both the space and a default basis in one line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/basis.jl#L214-L236">source</a></section></details></article><h2 id="Tensor-Product-(Basis)"><a class="docs-heading-anchor" href="#Tensor-Product-(Basis)">Tensor Product (Basis)</a><a id="Tensor-Product-(Basis)-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-Product-(Basis)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QSymbolic.:‚äó-Union{Tuple{B2}, Tuple{B1}, Tuple{B1, B2}} where {B1&lt;:AbstractBasis, B2&lt;:AbstractBasis}"><a class="docstring-binding" href="#QSymbolic.:‚äó-Union{Tuple{B2}, Tuple{B1}, Tuple{B1, B2}} where {B1&lt;:AbstractBasis, B2&lt;:AbstractBasis}"><code>QSymbolic.:‚äó</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">‚äó(basis1::AbstractBasis, basis2::AbstractBasis)
‚äó(cb::CompositeBasis, basis::AbstractBasis)
‚äó(basis::AbstractBasis, cb::CompositeBasis)</code></pre><p>Tensor product of bases. Supports chaining for multiple bases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/basis.jl#L97-L103">source</a></section></details></article><h2 id="Multiplication"><a class="docs-heading-anchor" href="#Multiplication">Multiplication</a><a id="Multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Multiplication" title="Permalink"></a></h2><p>Operator multiplication via bra-ket contraction:</p><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{S}, Tuple{Outer{S}, Outer{S}}} where S"><a class="docstring-binding" href="#Base.:*-Union{Tuple{S}, Tuple{Outer{S}, Outer{S}}} where S"><code>Base.:*</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Operator multiplication using bra-ket contraction.</p><p>For A = Œ£·µ¢ w·µ¢|a·µ¢‚ü©‚ü®b·µ¢| and B = Œ£‚±º v‚±º|c‚±º‚ü©‚ü®d‚±º|:     A * B = Œ£·µ¢‚±º w·µ¢v‚±º‚ü®b·µ¢|c‚±º‚ü© |a·µ¢‚ü©‚ü®d‚±º|</p><p>The contraction ‚ü®b·µ¢|c‚±º‚ü© uses bra-ket arithmetic, which handles:</p><ul><li>Same basis, same index: 1</li><li>Same basis, different index: 0</li><li>Cross-basis: InnerProduct or custom transform</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TendonFFF/QSymbolic.jl/blob/d73dd7aeb82fdfa998752839a9dd846ef54c3d28/src/arithmetic/operator_operator.jl#L7-L17">source</a></section></details></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="../bases/#QSymbolic.AbstractBasis"><code>QSymbolic.AbstractBasis</code></a></li><li><a href="../states/#QSymbolic.AbstractBra"><code>QSymbolic.AbstractBra</code></a></li><li><a href="../states/#QSymbolic.AbstractKet"><code>QSymbolic.AbstractKet</code></a></li><li><a href="../operators/#QSymbolic.AbstractOperator"><code>QSymbolic.AbstractOperator</code></a></li><li><a href="../spaces/#QSymbolic.AbstractSpace"><code>QSymbolic.AbstractSpace</code></a></li><li><a href="#QSymbolic.AbstractSymbolic"><code>QSymbolic.AbstractSymbolic</code></a></li><li><a href="../bases/#QSymbolic.Basis"><code>QSymbolic.Basis</code></a></li><li><a href="../states/#QSymbolic.Bra"><code>QSymbolic.Bra</code></a></li><li><a href="../bases/#QSymbolic.CompositeBasis"><code>QSymbolic.CompositeBasis</code></a></li><li><a href="../spaces/#QSymbolic.CompositeSpace"><code>QSymbolic.CompositeSpace</code></a></li><li><a href="../bases/#QSymbolic.DefaultBasis"><code>QSymbolic.DefaultBasis</code></a></li><li><a href="../operators/#QSymbolic.FunctionOperator"><code>QSymbolic.FunctionOperator</code></a></li><li><a href="../spaces/#QSymbolic.HilbertSpace"><code>QSymbolic.HilbertSpace</code></a></li><li><a href="../operators/#QSymbolic.Identity"><code>QSymbolic.Identity</code></a></li><li><a href="../states/#QSymbolic.Ket"><code>QSymbolic.Ket</code></a></li><li><a href="../symbolic/#QSymbolic.KroneckerDelta"><code>QSymbolic.KroneckerDelta</code></a></li><li><a href="../operators/#QSymbolic.Operator"><code>QSymbolic.Operator</code></a></li><li><a href="#QSymbolic.OperatorProduct"><code>QSymbolic.OperatorProduct</code></a></li><li><a href="#QSymbolic.OperatorSum"><code>QSymbolic.OperatorSum</code></a></li><li><a href="../operators/#QSymbolic.Outer"><code>QSymbolic.Outer</code></a></li><li><a href="../states/#QSymbolic.ProductBra"><code>QSymbolic.ProductBra</code></a></li><li><a href="../states/#QSymbolic.ProductKet"><code>QSymbolic.ProductKet</code></a></li><li><a href="../states/#QSymbolic.SumBra"><code>QSymbolic.SumBra</code></a></li><li><a href="../states/#QSymbolic.SumKet"><code>QSymbolic.SumKet</code></a></li><li><a href="../states/#QSymbolic.WeightedBra"><code>QSymbolic.WeightedBra</code></a></li><li><a href="../states/#QSymbolic.WeightedKet"><code>QSymbolic.WeightedKet</code></a></li><li><a href="#Base.:*-Union{Tuple{S}, Tuple{Outer{S}, Outer{S}}} where S"><code>Base.:*</code></a></li><li><a href="#Base.iterate-Tuple{HilbertSpace}"><code>Base.iterate</code></a></li><li><a href="#QSymbolic.:‚äó-Union{Tuple{B2}, Tuple{B1}, Tuple{B1, B2}} where {B1&lt;:AbstractBasis, B2&lt;:AbstractBasis}"><code>QSymbolic.:‚äó</code></a></li><li><a href="../spaces/#QSymbolic.:‚äó-Tuple{AbstractSpace, AbstractSpace}"><code>QSymbolic.:‚äó</code></a></li><li><a href="../bases/#QSymbolic.:‚äó-Tuple{AbstractBasis, AbstractBasis}"><code>QSymbolic.:‚äó</code></a></li><li><a href="../states/#QSymbolic.FockBra"><code>QSymbolic.FockBra</code></a></li><li><a href="../states/#QSymbolic.FockKet"><code>QSymbolic.FockKet</code></a></li><li><a href="../spaces/#QSymbolic.FockSpace"><code>QSymbolic.FockSpace</code></a></li><li><a href="../symbolic/#QSymbolic.Sym"><code>QSymbolic.Sym</code></a></li><li><a href="#QSymbolic.SymExpr"><code>QSymbolic.SymExpr</code></a></li><li><a href="#QSymbolic.SymNum"><code>QSymbolic.SymNum</code></a></li><li><a href="#QSymbolic.apply_contraction_rule"><code>QSymbolic.apply_contraction_rule</code></a></li><li><a href="../symbolic/#QSymbolic.assumptions"><code>QSymbolic.assumptions</code></a></li><li><a href="#QSymbolic.bases"><code>QSymbolic.bases</code></a></li><li><a href="../bases/#QSymbolic.basis1"><code>QSymbolic.basis1</code></a></li><li><a href="../bases/#QSymbolic.basis2"><code>QSymbolic.basis2</code></a></li><li><a href="../bases/#QSymbolic.basisname"><code>QSymbolic.basisname</code></a></li><li><a href="#QSymbolic.clear_contraction_rules!"><code>QSymbolic.clear_contraction_rules!</code></a></li><li><a href="../transforms/#QSymbolic.clear_transforms!"><code>QSymbolic.clear_transforms!</code></a></li><li><a href="#QSymbolic.define_contraction_rule!"><code>QSymbolic.define_contraction_rule!</code></a></li><li><a href="../transforms/#QSymbolic.define_transform!"><code>QSymbolic.define_transform!</code></a></li><li><a href="../symbolic/#QSymbolic.evaluate"><code>QSymbolic.evaluate</code></a></li><li><a href="#QSymbolic.get_contraction_rule"><code>QSymbolic.get_contraction_rule</code></a></li><li><a href="#QSymbolic.get_transform"><code>QSymbolic.get_transform</code></a></li><li><a href="#QSymbolic.has_contraction_rule"><code>QSymbolic.has_contraction_rule</code></a></li><li><a href="../transforms/#QSymbolic.has_transform"><code>QSymbolic.has_transform</code></a></li><li><a href="../symbolic/#QSymbolic.is_integer"><code>QSymbolic.is_integer</code></a></li><li><a href="#QSymbolic.is_nonnegative"><code>QSymbolic.is_nonnegative</code></a></li><li><a href="../symbolic/#QSymbolic.is_numeric"><code>QSymbolic.is_numeric</code></a></li><li><a href="../symbolic/#QSymbolic.is_positive"><code>QSymbolic.is_positive</code></a></li><li><a href="../symbolic/#QSymbolic.is_real"><code>QSymbolic.is_real</code></a></li><li><a href="../symbolic/#QSymbolic.simplify"><code>QSymbolic.simplify</code></a></li><li><a href="../operators/#QSymbolic.space-Tuple{AbstractOperator}"><code>QSymbolic.space</code></a></li><li><a href="../bases/#QSymbolic.space"><code>QSymbolic.space</code></a></li><li><a href="../symbolic/#QSymbolic.substitute"><code>QSymbolic.substitute</code></a></li><li><a href="../symbolic/#QSymbolic.symbols"><code>QSymbolic.symbols</code></a></li><li><a href="#QSymbolic.tr"><code>QSymbolic.tr</code></a></li><li><a href="../transforms/#QSymbolic.transform"><code>QSymbolic.transform</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../guide/contraction_rules/">¬´ Custom Contraction Rules</a><a class="docs-footer-nextpage" href="../spaces/">Spaces ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 4 January 2026 18:03">Sunday 4 January 2026</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
